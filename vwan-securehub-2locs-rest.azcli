############################################################################
# Created by Jose Moreno
# May 2020
#
# Creates a VWAN environment using the 2020-05-01 APIs for custom routing
############################################################################

# Variables
rg=vwan
vwan=vwan
location1=westeurope
location2=westcentralus
location3=uksouth
username=jose
password=Microsoft123!
publisher=cisco
offer=cisco-csr-1000v
sku=16_12-byol
version=$(az vm image list -p $publisher -f $offer -s $sku --all --query '[0].version' -o tsv)
vwan_hub1_prefix=192.168.1.0/24
azfw1_ip=192.168.1.68
rs1_ip=192.168.1.132
user_hub1_1st_octets=10.1.0
user_hub1_prefix=${user_hub1_1st_octets}.0/24
user_hub1_subnet=${user_hub1_1st_octets}.0/26
user_hub1_nva_ip=${user_hub1_1st_octets}.10
user_hub1_fw_subnet=${user_hub1_1st_octets}.128/26
spoke1_prefix=10.1.1.0/24
spoke1_subnet=10.1.1.0/26
spoke1_jump_subnet=10.1.1.64/26
spoke1_vm_ip=10.1.1.11
spoke1_jump_ip=10.1.1.75
spoke2_prefix=10.1.2.0/24
spoke2_subnet=10.1.2.0/26
spoke2_vm_ip=10.1.2.11
spoke2_jump_subnet=10.1.2.64/26
spoke2_jump_ip=10.1.2.75
branch1_prefix=10.1.201.0/24
branch1_subnet=10.1.201.0/26
branch1_bgp_ip=10.1.201.10
vwan_hub2_prefix=192.168.2.0/24
azfw2_ip=192.168.2.68
rs2_ip=192.168.2.132
branch2_prefix=10.2.202.0/24
branch2_subnet=10.2.202.0/26
branch2_bgp_ip=10.2.202.10
branch3_prefix=10.2.203.0/24
branch3_subnet=10.2.203.0/26
branch3_bgp_ip=10.2.203.10
user_hub2_1st_octets=10.2.0
user_hub2_prefix=${user_hub2_1st_octets}.0/24
user_hub2_subnet=${user_hub2_1st_octets}.0/26
user_hub2_nva_ip=${user_hub2_1st_octets}.10
user_hub2_fw_subnet=${user_hub2_1st_octets}.128/26
spoke3_prefix=10.2.3.0/24
spoke3_subnet=10.2.3.0/26
spoke3_vm_ip=10.2.3.11
spoke3_jump_subnet=10.2.3.64/26
spoke3_jump_ip=10.2.3.75
spoke4_prefix=10.2.4.0/24
spoke4_subnet=10.2.4.0/26
spoke4_vm_ip=10.2.4.11
spoke4_jump_subnet=10.2.4.64/26
spoke4_jump_ip=10.2.4.75
vwan_hub1_asn=65515
vwan_hub2_asn=65515
branch1_asn=65501
branch2_asn=65502
branch3_asn=65503
nva_size=Standard_B2ms
vm_size=Standard_B1ms
logws_name=log$RANDOM


####################
#   JSON scripts   #
####################

# REST Variables
vwan_api_version=2020-05-01
subscription_id=$(az account show --query id -o tsv)
# JSON
vwan_json='{location: $location, properties: {disableVpnEncryption: false, type: $sku}}'
vhub_json='{location: $location, properties: {virtualWan: {id: $vwan_id}, addressPrefix: $hub_prefix, sku: $sku}}'
vpnsitelink_json='{name: $link_name, properties: {ipAddress: $remote_pip, bgpProperties: {bgpPeeringAddress: $remote_bgp_ip, asn: $remote_asn}, linkProperties: {linkProviderName: "vendor1", linkSpeedInMbps: 100}}}'
vpnsite_json='{location: $location, properties: {virtualWan: {id: $vwan_id}, addressSpace: { addressPrefixes: [ $site_prefix ] }, isSecuritySite: $security, vpnSiteLinks: [ '${vpnsitelink_json}']}}'
cx_json='{name: $cx_name, properties: {connectionBandwidth: 200, vpnConnectionProtocolType: "IKEv2", enableBgp: true, sharedKey: $psk, vpnSiteLink: {id: $site_link_id}}}'
vpncx_json='{properties: {enableInternetSecurity: true, remoteVpnSite: {id: $site_id}, vpnLinkConnections: ['$cx_json']}}'
vpngw_json='{location: $location, properties: {virtualHub: {id: $vhub_id}, connections: [], bgpSettings: {asn: $asn, peerWeight: 0}}}'
vnet_cx_json='{properties: {remoteVirtualNetwork: {id: $vnet_id}, enableInternetSecurity: true}}'
rt_json='{properties: {routes: [], labels: []}}'
route_json='{name: $name, destinationType: "CIDR", destinations: [ $prefixes ], nextHopType: $type, nextHop: $nexthop }'
cxroute_json='{name: $name, addressPrefixes: [ $prefixes ], nextHopIpAddress: $nexthop }'
# REST URIs
vwan_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualWans/$vwan?api-version=$vwan_api_version"
vhubs_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs?api-version=$vwan_api_version"
vhub1_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub1"
vhub2_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub2"
vhub3_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub3"
vhub1_uri="${vhub1_base_uri}?api-version=$vwan_api_version"
vhub1_ipconfigs_uri="${vhub1_base_uri}/ipConfigurations?api-version=$vwan_api_version"
vhub1_bgp_uri="${vhub1_base_uri}/bgpConnections?api-version=$vwan_api_version"
vhub1_vnetcx_uri="${vhub1_base_uri}/hubVirtualNetworkConnections?api-version=$vwan_api_version"
vhub1_vnetcx1_uri="${vhub1_base_uri}/hubVirtualNetworkConnections/spoke1?api-version=$vwan_api_version"
vhub1_vnetcx2_uri="${vhub1_base_uri}/hubVirtualNetworkConnections/spoke2?api-version=$vwan_api_version"
vhub1_vnetcxhub1_uri="${vhub1_base_uri}/hubVirtualNetworkConnections/userhub1?api-version=$vwan_api_version"
vhub1_rt_uri="${vhub1_base_uri}/routeTables?api-version=$vwan_api_version"
vhub1_hubrt_uri="${vhub1_base_uri}/hubRouteTables?api-version=$vwan_api_version"
vhub1_effrt_uri="${vhub1_base_uri}/effectiveRoutes?api-version=$vwan_api_version"
vhub1_default_hubrt_uri="${vhub1_base_uri}/hubRouteTables/defaultRouteTable?api-version=$vwan_api_version"
vhub2_uri="${vhub2_base_uri}?api-version=$vwan_api_version"
vhub2_rt_uri="${vhub2_base_uri}/routeTables?api-version=$vwan_api_version"
vhub2_hubrt_uri="${vhub2_base_uri}/hubRouteTables?api-version=$vwan_api_version"
vhub2_default_hubrt_uri="${vhub2_base_uri}/hubRouteTables/defaultRouteTable?api-version=$vwan_api_version"
vhub2_vnetcx_uri="${vhub2_base_uri}/hubVirtualNetworkConnections?api-version=$vwan_api_version"
vhub2_vnetcx3_uri="${vhub2_base_uri}/hubVirtualNetworkConnections/spoke3?api-version=$vwan_api_version"
vhub2_vnetcx4_uri="${vhub2_base_uri}/hubVirtualNetworkConnections/spoke4?api-version=$vwan_api_version"
vhub2_vnetcxhub2_uri="${vhub2_base_uri}/hubVirtualNetworkConnections/userhub2?api-version=$vwan_api_version"
vhub3_uri="${vhub3_base_uri}?api-version=$vwan_api_version"
vpnsites_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites?api-version=$vwan_api_version"
vpnsite1_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/branch1?api-version=$vwan_api_version"
vpnsite2_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/branch2?api-version=$vwan_api_version"
vpnsite3_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/branch3?api-version=$vwan_api_version"
vpngws_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways?api-version=$vwan_api_version"
vpngw1_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn1"
vpngw1_uri="${vpngw1_base_uri}?api-version=$vwan_api_version"
vpngw1_cx_uri="${vpngw1_base_uri}/vpnConnections?api-version=$vwan_api_version"
vpngw1_cx1_uri="${vpngw1_base_uri}/vpnConnections/branch1?api-version=$vwan_api_version"
vpngw2_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn2"
vpngw2_uri="${vpngw2_base_uri}?api-version=$vwan_api_version"
vpngw2_cx_uri="${vpngw2_base_uri}/vpnConnections?api-version=$vwan_api_version"
vpngw2_cx2_uri="${vpngw2_base_uri}/vpnConnections/branch2?api-version=$vwan_api_version"
vpngw2_cx3_uri="${vpngw2_base_uri}/vpnConnections/branch3?api-version=$vwan_api_version"

####################
# Helper functions #
####################

wait_interval=5
function wait_until_finished {
     resource_id=$1
     resource_name=$(echo $resource_id | cut -d/ -f 9)
     echo "Waiting for resource $resource_name to finish provisioning..."
     start_time=`date +%s`
     state=$(az resource show --id $resource_id --query properties.provisioningState -o tsv)
     until [[ "$state" == "Succeeded" ]] || [[ "$state" == "Failed" ]] || [[ -z "$state" ]]
     do
        sleep $wait_interval
        state=$(az resource show --id $resource_id --query properties.provisioningState -o tsv)
     done
     if [[ -z "$state" ]]
     then
        echo "Something really bad happened..."
        exit
     else
        run_time=$(expr `date +%s` - $start_time)
        ((minutes=${run_time}/60))
        ((seconds=${run_time}%60))
        echo "Resource $resource_name provisioning state is $state, wait time $minutes minutes and $seconds seconds"
     fi
}

function wait_until_hub_finished {
    hub_name=$1
    hub_id=$(az network vhub show -n $hub_name -g $rg --query id -o tsv)
    wait_until_finished $hub_id
    echo "Hub state is $(get_vhub_state $hub_name), checking connections..."
    connections=$(get_vnetcx_state $hub_name | grep Updating)
    until [[ -z "$connections" ]]
    do
        sleep $wait_interval
        connections=$(get_vnetcx_state $hub_name | grep Updating)
    done
    echo "No connections in Updating state in hub $hub_name, checking route tables..."
    rts=$(get_rt_state $hub_name | grep Updating)
    until [[ -z "$rts" ]]
    do
        sleep $wait_interval
        rts=$(get_rt_state $hub_name | grep Updating)
    done
}

function wait_until_gw_finished {
    gw_name=$1
    gw_id=$(az network vpn-gateway show -n $gw_name -g $rg --query id -o tsv)
    wait_until_finished $gw_id
}

# Get JSON for a hub or all hubs
function get_vhub {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}?api-version=$vwan_api_version"
    if [[ -z "${hub_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a hub or all hubs
function get_vhub_state {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}?api-version=$vwan_api_version"
    if [[ -z "${hub_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

function list_vhub {
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name'
}


# Get JSON for a vnet connection or all vnet connections in a hub
function get_vnetcx {
    hub_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a vnet cx in a hub or all vnet cx in a hub
function get_vnetcx_state {
    hub_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

# List vnet connections
function list_vnetcx {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name' 2>/dev/null
}

# Get JSON for a hubRT or all hubRTs
function get_rt {
    hub_name=$1
    rt_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    if [[ -z "${rt_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a hubRT or all hubRTs
function get_rt_state {
    hub_name=$1
    rt_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    if [[ -z "${rt_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

# Get provisioningState for a hubRT or all hubRTs
function list_rt {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name'
}

# Get JSON for a vpngw or all vpngw
function get_vpngw {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${gw_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a VPN GW or all VPN GWs
function get_vpngw_state {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${gw_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

function list_vpngw {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name'
}

# Get BGP info for a VPN GW or all VPN GWs
function get_vpngw_bgp {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${gw_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.bgpSettings})'
    else
        az rest --method get --uri $uri | jq -r '.properties.bgpSettings'
    fi
}

# Get VPN connections
function get_vpngw_cx {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.properties.connections'
    else
        az rest --method get --uri $uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'")'
    fi
}

# Get VPN connections state
function get_vpngw_cx_state {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.properties.connections | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'") | .properties.provisioningState'
    fi
}

# Get JSON for a VPN site or all VPN sites
function get_vpnsite {
    site_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    if [[ -z "${site_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a VPN site or all VPN sites
function get_vpnsite_state {
    site_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    if [[ -z "${site_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

#################
#       RT      #
#################

# Create Route Table (aka hubRouteTable)
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate
function create_rt {
    hub_name=$1
    rt_name=$2
    rt_json_string=$(jq -n \
            $rt_json)
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    az rest --method put --uri $rt_uri --body $rt_json_string   # PUT
    # az rest --method get --uri $rt_uri                        # GET
    # az rest --method delete --uri $rt_uri                     # DELETE
}

# Delete rt
function delete_rt {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    az rest --method delete --uri $rt_uri
}

# Update vnet connection associated RT
function cx_set_ass_rt {
    hub_name=$1
    cx_name=$2
    new_rt_name=$3
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_rt_id="/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_rt_name}"
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.associatedRouteTable.id = "'$new_rt_id'" | {name, properties}')
    az rest --method put --uri $cx_uri --body $cx_json_updated
    az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.associatedRouteTable.id'
}

# Update vnet connection propagated RT
# Example: cx_set_prop_rt hub1 spoke1 redRT,defaultRouteTable
function cx_set_prop_rt {
    hub_name=$1
    cx_name=$2
    IFS=',' read -r -a new_rt_names <<< "$3"
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_rt_ids=""
    for new_rt_name in ${new_rt_names[@]}; do
        new_rt_ids="${new_rt_ids}{\"id\": \"/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_rt_name}\"},"
    done
    new_rt_ids="${new_rt_ids: : -1}"   # Remove trailing comma
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.propagatedRouteTables.ids = ['$new_rt_ids'] | {name, properties}')
    az rest --method put --uri $cx_uri --body $cx_json_updated
}

# Modify propagation labels
function cx_set_prop_labels {
    hub_name=$1
    cx_name=$2
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_labels <<< "$3"
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_labels_txt=""
    for new_label in ${new_labels[@]}; do
        new_labels_txt="${new_labels_txt}\"${new_label}\","
    done
    new_labels_txt="${new_labels_txt: : -1}"   # Remove trailing comma
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.propagatedRouteTables.labels = ['${new_labels_txt}'] | {name, properties}')
    az rest --method put --uri $cx_uri --body $cx_json_updated
}

# Modify propagated RT for VPN connection
function vpncx_set_prop_rt {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_rt_names <<< "$3"
    hub_id=$(az network vpn-gateway show -n $gw_name -g $rg --query 'virtualHub.id' -o tsv)
    hub_name=$(echo $hub_id | cut -d/ -f 9)
    new_rt_ids=""
    for new_rt_name in ${new_rt_names[@]}
    do
        new_rt_ids="${new_rt_ids}{\"id\": \"/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_rt_name}\"},"
    done
    new_rt_ids="${new_rt_ids: : -1}"   # Remove trailing comma
    vpn_json=$(az rest --method get --uri $uri)
    connections=$(echo $vpn_json | jq '.properties.connections | map({name, properties})')
    # Remove unneeded attributes
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].resourceGroup)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].etag)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].type)')
    connections_updated=$(echo $connections | jq 'map(if .name=="'$cx_name'" then .properties.routingConfiguration.propagatedRouteTables.ids=['"$new_rt_ids"'] else . end)')
    vpn_json_updated=$(echo $vpn_json | jq '.properties.connections = '${connections_updated}' | {name, properties, location}')
    az rest --method put --uri $uri --body $vpn_json_updated
}

function vpncx_set_prop_labels {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_labels <<< "$3"
    hub_id=$(az network vpn-gateway show -n $gw_name -g $rg --query 'virtualHub.id' -o tsv)
    hub_name=$(echo $hub_id | cut -d/ -f 9)
    new_labels_txt=""
    for new_label in ${new_labels[@]}; do
        new_labels_txt="${new_labels_txt}\"${new_label}\","
    done
    new_labels_txt="${new_labels_txt: : -1}"   # Remove trailing comma
    vpn_json=$(az rest --method get --uri $uri)
    connections=$(echo $vpn_json | jq '.properties.connections | map({name, properties})')
    # Remove unneeded attributes
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].resourceGroup)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].etag)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].type)')
    connections_updated=$(echo $connections | jq 'map(if .name=="'$cx_name'" then .properties.routingConfiguration.propagatedRouteTables.labels=['"$new_labels_txt"'] else . end)')
    vpn_json_updated=$(echo $vpn_json | jq '.properties.connections = '${connections_updated}' | {name, properties, location}')
    az rest --method put --uri $uri --body $vpn_json_updated
}

# Update vnet connection associated and propagated RT at the same time
# example: cx_set_rt hub1 spoke1 redRT redRT,defaultRouteTable
function cx_set_rt {
    hub_name=$1
    cx_name=$2
    new_assrt_name=$3
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_proprt_names <<< "$4"
    echo "Setting associated route table to $new_assrt_name, propagated route tables to $new_proprt_names"  # DEBUG
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_assrt_id="/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_assrt_name}"
    new_proprt_ids=""
    for new_proprt_name in ${new_proprt_names[@]}; do
        new_proprt_ids="${new_proprt_ids}{\"id\": \"/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_proprt_name}\"},"
    done
    new_proprt_ids="${new_proprt_ids: : -1}"   # Remove trailing comma
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.associatedRouteTable.id = "'$new_assrt_id'" | .properties.routingConfiguration.propagatedRouteTables.ids = ['$new_proprt_ids'] | {name, properties}')
    az rest --method put --uri $cx_uri --body $cx_json_updated
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.associatedRouteTable.id'
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.propagatedRouteTables.ids'
    # az rest --method get --uri $cx_uri | jq '.properties.provisioningState'
}

# Add routes to RT
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate#hubroute
function rt_add_route {
    hub_name=$1
    rt_name=$2
    prefix=$3
    nexthop=$4
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    # type (next hop): CIDR, resourceId, Service
    # prefixes: comma-separated prefix list
    new_route_json_string=$(jq -n \
            --arg name "route$RANDOM" \
            --arg type "ResourceId" \
            --arg prefixes "$prefix" \
            --arg nexthop "$nexthop" \
            $route_json)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.routes += [ '$new_route_json_string' ] | {name, properties}')
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
    az rest --method get --uri $rt_uri | jq '.properties.routes'  # GET
}

# Delete all routes from RT
function rt_delete_routes {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.routes = [] | {name, properties}')
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
    az rest --method get --uri $rt_uri | jq '.properties.routes'  # GET
}

# Add routes to vnet conection
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubvirtualnetworkconnections/createorupdate#staticroute
# Example: cx_add_routes hub1 spoke1 192.168.0.0/16 172.21.10.68
function cx_add_routes {
    hub_name=$1
    cx_name=$2
    prefix=$3
    nexthop=$4
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    # prefixes: comma-separated prefix list
    new_route_json_string=$(jq -n \
            --arg name "route$RANDOM" \
            --arg prefixes "$prefix" \
            --arg nexthop "$nexthop" \
            $cxroute_json)
    existing_routes=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes[]')
    if [ -z "${existing_routes}" ]
    then
        new_routes=${new_route_json_string}
    else
        new_routes=${existing_routes},${new_route_json_string}
    fi
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes = ['$new_routes'] | {name, properties}')
    az rest --method put --uri $cx_uri --body $cx_json_updated  # PUT
    az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes'  # GET
}

# Delete all routes from vnet cx
function cx_delete_routes {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes = [] | {name, properties}')
    az rest --method put --uri $cx_uri --body $cx_json_updated    # PUT
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes'  # GET
}

# Delete all labels from vnet cx
function cx_delete_labels {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.propagatedRouteTables.labels = [] | {name, properties}')
    az rest --method put --uri $cx_uri --body $cx_json_updated    # PUT
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.propagatedRouteTables.labels'  # GET
}

# Add label to route table
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate#hubroute
function rt_add_label {
    hub_name=$1
    rt_name=$2
    new_label=$3
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.labels += [ "'$new_label'" ] | {name, properties}')
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
}

# Delete all labels
function rt_delete_labels {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.labels = [] | {name, properties}')
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
}


#################
#  Reset stuff  #
#################

# reset vhub
function reset_vhub {
    hub_name=$1
    hub_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}?api-version=$vwan_api_version"
    hub_json_current=$(az rest --method get --uri $hub_uri)
    hub_json_updated=$(echo $hub_json_current | jq '{name, location, properties}')
    az rest --method put --uri $hub_uri --body $hub_json_updated
}

# reset vhub
function reset_rt {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '{name, location, properties}')
    az rest --method put --uri $rt_uri --body $rt_json_updated
}

# reset vnet cx
function reset_vhub_cx {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json_current=$(az rest --method get --uri $cx_uri)       # GET
    cx_json_updated=$(echo $cx_json_current | jq '{name, location, properties}')
    # az rest --method delete --uri $cx_uri                     # DELETE
    # Here you should wait until the delete operation finishes!!!!
    az rest --method put --uri $cx_uri --body $cx_json_updated  # PUT
}

# reset vpngw - NOT WORKING!
function reset_vpngw {
    gw_name=$1
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    gw_json_current=$(az rest --method get --uri $gw_uri)
    gw_json_updated=$(echo $gw_json_current | jq '{name, location, properties}')
    az rest --method put --uri $gw_uri --body $gw_json_updated
}


##################
#  Summary info  #
##################

# Get label info
function get_cx_labels {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    az rest --method get --uri $cx_uri | jq -r '.properties.routingConfiguration.propagatedRouteTables.labels[]' | paste -sd, - 2>/dev/null
}
function get_rt_labels {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    az rest --method get --uri $rt_uri | jq -r '.properties.labels[]' | paste -sd, - 2>/dev/null
}
function get_rt_routes {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    az rest --method get --uri $rt_uri | jq -r '.properties.routes[] | .destinations[],.nextHop' | paste -sd, - 2>/dev/null
}
function get_vpncx_labels {
    gw_name=$1
    cx_name=$2
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    az rest --method get --uri $gw_uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'") | .properties.routingConfiguration.propagatedRouteTables.labels[]' | paste -sd, - 2>/dev/null
}
function list_vpncx {
    gw_name=$1
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    az rest --method get --uri $gw_uri | jq -r '.properties.connections[].name' 2>/dev/null
}

function labels {
    # Vnet connections
    hubs=$(list_vhub)
    while IFS= read -r hub_name; do
        vnet_cxs=$(list_vnetcx $hub_name)
        if [[ -n "$vnet_cxs" ]]
        then
            while IFS= read -r vnetcx_name; do
                echo "${hub_name}/${vnetcx_name} connection:  $(get_cx_labels $hub_name $vnetcx_name)"
            done <<< "$vnet_cxs"
        else
            echo "No vnet connections in hub $hub_name"
        fi
    done <<< "$hubs"
    # VPN connections
    vpngws=$(list_vpngw)
    while IFS= read -r gw_name; do
        vpn_cxs=$(list_vpncx $gw_name)
        if [[ -n "$vpn_cxs" ]]
        then
            while IFS= read -r vpncx_name; do
                echo "${gw_name}/${vpncx_name} connection:  $(get_vpncx_labels $gw_name $vpncx_name)"
            done <<< "$vpn_cxs"
        else
            echo "No VPN connections in gateway $gw_name"
        fi
    done <<< "$vpngws"
    # Route Tables
    while IFS= read -r hub_name; do
        rts=$(list_rt $hub_name)
        if [[ -n "$rts" ]]
        then
            while IFS= read -r rt_name; do
                echo "${hub_name}/${rt_name}:  $(get_rt_labels $hub_name $rt_name)"
            done <<< "$rts"
        else
            echo "No route tables in hub $hub_name"
        fi
    done <<< "$hubs"
}

function state {
    # Hubs
    hubs=$(list_vhub)
    while IFS= read -r hub_name; do
        echo "${hub_name}: $(get_vhub_state $hub_name)"
        # Vnet connections
        vnet_cxs=$(list_vnetcx $hub_name)
        if [[ -n "$vnet_cxs" ]]
        then
            while IFS= read -r vnetcx_name; do
                echo "${hub_name}/${vnetcx_name} connection:  $(get_vnetcx_state $hub_name $vnetcx_name)"
            done <<< "$vnet_cxs"
        else
            echo "No vnet connections in hub $hub_name"
        fi
        # Route Tables
        rts=$(list_rt $hub_name)
        if [[ -n "$rts" ]]
        then
            while IFS= read -r rt_name; do
                echo "${hub_name}/${rt_name}:  $(get_rt_state $hub_name $rt_name)"
            done <<< "$rts"
        else
            echo "No route tables in hub $hub_name"
        fi
    done <<< "$hubs"
    # VPN connections
    vpngws=$(list_vpngw)
    while IFS= read -r gw_name; do
        echo "${gw_name}: $(get_vpngw_state $gw_name)"
        vpn_cxs=$(list_vpncx $gw_name)
        if [[ -n "$vpn_cxs" ]]
        then
            while IFS= read -r vpncx_name; do
                echo "${gw_name}/${vpncx_name} connection:  $(get_vpngw_cx_state $gw_name $vpncx_name)"
            done <<< "$vpn_cxs"
        else
            echo "No VPN connections in gateway $gw_name"
        fi
    done <<< "$vpngws"
}

# Get associated/propagated routing tables
function print_routing {
    routing=$1
    assrt=$(echo $routing | jq -r '.associatedRouteTable.id')
    assrt_hub=$(echo $assrt | cut -d/ -f 9)
    assrt_name=$(echo $assrt | cut -d/ -f 11)
    proprt=$(echo $routing | jq -r '.propagatedRouteTables.ids[].id')
    proprt_txt=""
    while IFS= read -r proprt_id; do
        proprt_hub=$(echo $proprt_id | cut -d/ -f 9)
        proprt_name=$(echo $proprt_id | cut -d/ -f 11)
        if [[ -n "$proprt_txt" ]]
        then
            proprt_txt+=", "
        fi
        proprt_txt+=${proprt_hub}/${proprt_name}
    done <<< "$proprt"
    proplbls=$(echo $routing | jq -r '.propagatedRouteTables.labels[]')
    proplbl_txt=""
    while IFS= read -r label; do
        if [[ -n "$proplbl_txt" ]]
        then
            proplbl_txt+=", "
        fi
        proplbl_txt+=${label}
    done <<< "$proplbls"
    echo "  * Associated: ${assrt_hub}/${assrt_name}"
    echo "  * Propagated: $proprt_txt - Labels: ${proplbl_txt}"
}
function get_cx_routing {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    routing=$(az rest --method get --uri $cx_uri | jq -r '.properties.routingConfiguration')
    echo "$hub_name / $cx_name"
    print_routing $routing
}
function get_vpncx_routing {
    gw_name=$1
    cx_name=$2
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    routing=$(az rest --method get --uri $gw_uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'") | .properties.routingConfiguration')
    echo "$gw_name / $cx_name"
    print_routing $routing
}

function routing {
    # Vnet connections
    hubs=$(list_vhub)
    while IFS= read -r hub_name; do
        vnet_cxs=$(list_vnetcx $hub_name)
        if [[ -n "$vnet_cxs" ]]
        then
            while IFS= read -r vnetcx_name; do
                get_cx_routing $hub_name $vnetcx_name
            done <<< "$vnet_cxs"
        else
            echo "No vnet connections in hub $hub_name"
        fi
    done <<< "$hubs"
    # VPN connections
    vpngws=$(list_vpngw)
    while IFS= read -r gw_name; do
        vpn_cxs=$(list_vpncx $gw_name)
        if [[ -n "$vpn_cxs" ]]
        then
            while IFS= read -r vpncx_name; do
                get_vpncx_routing $gw_name $vpncx_name
            done <<< "$vpn_cxs"
        else
            echo "No VPN connections in gateway $gw_name"
        fi
    done <<< "$vpngws"
}

################
# Getting logs #
################

function get_fw_logs_net {
    query='AzureDiagnostics
    | where Category == "AzureFirewallNetworkRule"
    | where TimeGenerated >= ago(5m) 
    | parse msg_s with Protocol " request from " SourceIP ":" SourcePortInt:int " to " TargetIP ":" TargetPortInt:int *
    | parse msg_s with * ". Action: " Action1a
    | parse msg_s with * " was " Action1b " to " NatDestination
    | parse msg_s with Protocol2 " request from " SourceIP2 " to " TargetIP2 ". Action: " Action2
    | extend SourcePort = tostring(SourcePortInt),TargetPort = tostring(TargetPortInt)
    | extend Action = case(Action1a == "", case(Action1b == "",Action2,Action1b), Action1a),Protocol = case(Protocol == "", Protocol2, Protocol),SourceIP = case(SourceIP == "", SourceIP2, SourceIP),TargetIP = case(TargetIP == "", TargetIP2, TargetIP),SourcePort = case(SourcePort == "", "N/A", SourcePort),TargetPort = case(TargetPort == "", "N/A", TargetPort),NatDestination = case(NatDestination == "", "N/A", NatDestination)
    //| where Action == "Deny" 
    //| project TimeGenerated, msg_s, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // with msg_s
    | project TimeGenerated, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // without msg_s
    | take 20 '
    az monitor log-analytics query -w $logws_customerid --analytics-query $query -o tsv
}

function get_fw_logs_app {
    query='AzureDiagnostics 
    | where ResourceType == "AZUREFIREWALLS" 
    | where Category == "AzureFirewallApplicationRule" 
    | where TimeGenerated >= ago(5m) 
    | project Protocol=split(msg_s, " ")[0], From=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",3,4)], To=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",5,6)], Action=trim_end(".", tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",7,8)])), Rule_Collection=iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="traffic.", "AzureInternalTraffic", iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="matched.","NoRuleMatched",trim_end(".",tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)])))), Rule=iif(split(msg_s, " ")[11]=="Proceeding" or split(msg_s, " ")[12]=="Proceeding","DefaultAction",split(msg_s, " ")[12]), msg_s 
    | where Rule_Collection != "AzureInternalTraffic" 
    //| where Action == "Deny" 
    | take 20'
    az monitor log-analytics query -w $logws_customerid --analytics-query $query -o tsv
}

##################
# VM Maintenance #
##################
function stop_vms {
    vms=$(az vm list -g $rg --query '[].name' -o tsv)
    while IFS= read -r vm_name; do
        echo "Stopping ${vm_name}..."
        az vm deallocate -n $vm_name -g $rg --no-wait
    done <<< "$vms"
    az vm list -d -g $rg -o table
}
function start_vms {
    vms=$(az vm list -g $rg --query '[].name' -o tsv)
    while IFS= read -r vm_name; do
        echo "Starting ${vm_name}..."
        az vm start -n $vm_name -g $rg --no-wait
    done <<< "$vms"
    az vm list -d -g $rg -o table
}

function add_to_hosts {
    ip=$1
    if [[ -n "$ip" ]]
    then
        ssh-keyscan -H $ip >> ~/.ssh/known_hosts
    fi
}

function get_ips {
    echo "Getting public IP addresses..."
    spoke11_jump_pip=$(az network public-ip show -n spoke11-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke11_jump_pip
    add_to_hosts $spoke11_jump_pip
    spoke12_jump_pip=$(az network public-ip show -n spoke12-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke12_jump_pip
    add_to_hosts $spoke12_jump_pip
    spoke13_jump_pip=$(az network public-ip show -n spoke13-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke13_jump_pip
    add_to_hosts $spoke13_jump_pip
    spoke14_jump_pip=$(az network public-ip show -n spoke14-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke14_jump_pip
    add_to_hosts $spoke14_jump_pip
    spoke15_jump_pip=$(az network public-ip show -n spoke15-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke15_jump_pip
    add_to_hosts $spoke15_jump_pip
    spoke21_jump_pip=$(az network public-ip show -n spoke21-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke21_jump_pip
    add_to_hosts $spoke21_jump_pip
    spoke22_jump_pip=$(az network public-ip show -n spoke22-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke22_jump_pip
    add_to_hosts $spoke22_jump_pip
    spoke23_jump_pip=$(az network public-ip show -n spoke23-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke23_jump_pip
    add_to_hosts $spoke23_jump_pip
    spoke24_jump_pip=$(az network public-ip show -n spoke24-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke24_jump_pip
    add_to_hosts $spoke24_jump_pip
    spoke25_jump_pip=$(az network public-ip show -n spoke25-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke25_jump_pip
    add_to_hosts $spoke25_jump_pip
    branch1_ip=$(az network public-ip show -n branch1-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $branch1_ip
    add_to_hosts $branch1_ip
    branch2_ip=$(az network public-ip show -n branch2-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $branch2_ip
    add_to_hosts $branch2_ip
    branch3_ip=$(az network public-ip show -n branch3-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $branch3_ip
    add_to_hosts $branch3_ip
}

###################
#  Create vnets   #
###################

# Creates spoke vnets and connects it to hub
# create_spokes <hub_id> <number_of_spokes>
# create_spokes 1 5
function create_spokes {
    hub_id=$1
    hub_name=hub$1
    vhub_id=$(az network vhub show -n $hub_name -g $rg --query id -o tsv)
    num_of_spokes=$2
    # Get location
    if [[ "$hub_id" == "1" ]]
    then
        location=$location1
    else
        if [[ "$hub_id" == "2" ]]
        then
            location=$location2
        else
            location=$location3
        fi
    fi
    # Create route-table to send traffic to this PC over Internet
    mypip=$(curl -s4 ifconfig.co)
    echo "Creating route table to send traffic to $mypip over the Internet..."
    az network route-table create -n jumphost-$location -g $rg -l $location >/dev/null
    az network route-table route create -n mypc -g $rg --route-table-name jumphost-$location --address-prefix "${mypip}/32" --next-hop-type Internet >/dev/null
    # Create spokes
    echo "Starting creating $num_of_spokes spokes in $location to attach to hub${hub_id}"
    for (( spoke_id=1 ; spoke_id <= ${num_of_spokes}; spoke_id++ ))
    do
        # Set variables
        # Create jump host
        vm_name=spoke${hub_id}${spoke_id}
        pip_name=${vm_name}-pip
        vnet_name=${vm_name}-$location
        vnet_prefix=10.${hub_id}.${spoke_id}.0/24
        subnet_prefix=10.${hub_id}.${spoke_id}.64/26
        vm_ip=10.${hub_id}.${spoke_id}.75
        echo "Creating VM ${vm_name}-jumphost..."
        az vm create -n ${vm_name}-jumphost -g $rg -l $location --image ubuntuLTS --admin-username $username --generate-ssh-keys --size $vm_size \
                    --public-ip-address $pip_name --vnet-name $vnet_name --vnet-address-prefix $vnet_prefix \
                    --subnet jumphost --subnet-address-prefix $subnet_prefix --private-ip-address $vm_ip --no-wait
        # Optionally, add VM without PIP
        # subnet_prefix=10.${hub_id}.${spoke_id}.0/26
        # vm_ip=10.${hub_id}.${spoke_id}.11
        # echo "Creating VM ${vm_name}-test..."
        # az vm create -n ${vm_name}-test -g $rg -l $location --image ubuntuLTS --admin-username $username --generate-ssh-keys --size $vm_size \
        #     --public-ip-address "" --vnet-name $vnet_name --vnet-address-prefix $vnet_prefix \
        #     --subnet vm --subnet-address-prefix $subnet_prefix --private-ip-address $vm_ip --no-wait
    done
    # Do another pass to add the IPs to known_hosts and create vnet-hub connections
    for (( spoke_id=1 ; spoke_id <= ${num_of_spokes}; spoke_id++ ))
    do
        vm_name=spoke${hub_id}${spoke_id}
        pip_name=${vm_name}-pip
        vnet_name=${vm_name}-$location
        # Attach route table to jumphost subnet for SSH traffic
        echo "Attaching route table jumphost-$location to vnet ${vnet_name}..."
        az network vnet subnet update -n jumphost --vnet-name $vnet_name -g $rg --route-table jumphost-$location >/dev/null
        # Get PIP and add it to known_hosts
        echo "Getting IP address for $pip_name..."
        spoke_jump_pip=$(az network public-ip show -n $pip_name -g $rg --query ipAddress -o tsv)
        echo "Adding $spoke_jump_pip to SSH known_hosts..."
        ssh-keyscan -H $spoke_jump_pip >> ~/.ssh/known_hosts 2>/dev/null
        ssh -n -o BatchMode=yes $spoke_jump_pip "ip a"
        # Associate vnet to hub
        vnet_id=$(az network vnet show -n $vnet_name -g $rg --query id -o tsv)
        vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
        vhub_uri="${vhub_base_uri}?api-version=$vwan_api_version"
        vhub_vnetcx_uri="${vhub_base_uri}/hubVirtualNetworkConnections/${vm_name}?api-version=$vwan_api_version"
        vnet_cx_json_string=$(jq -n \
                --arg vnet_id "$vnet_id" \
                $vnet_cx_json)
        # Optionally, modify properties for the connection
        # vnet_cx_json_string=$(echo $vnet_cx_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.labels = ["red"]')
        echo "Associating vnet $vnet_name to hub hub${hub_id}..."
        # Wait for hub to be Succeeded (do we need to wait for the other connections to be succeeded)
        echo "Waiting for hub to reach the Succeeded state..."
        wait_until_hub_finished $hub_name
        # Create connection
        az rest --method put --uri $vhub_vnetcx_uri --body $vnet_cx_json_string >/dev/null
    done
}

function connect_spoke {
    hub_id=$1
    spoke_id=$2
    # Variables
    if [[ "$hub_id" == "1" ]]
    then
        location=$location1
    else
        if [[ "$hub_id" == "2" ]]
        then
            location=$location2
        else
            location=$location3
        fi
    fi
    vm_name=spoke${hub_id}${spoke_id}
    vnet_name=${vm_name}-$location
    echo "Finding out resource ID for vnet ${vnet_name}..."
    vnet_id=$(az network vnet show -n $vnet_name -g $rg --query id -o tsv)
    vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
    vhub_vnetcx_uri="${vhub_base_uri}/hubVirtualNetworkConnections/${vm_name}?api-version=$vwan_api_version"
    # Create JSON
    vnet_cx_json_string=$(jq -n \
            --arg vnet_id "$vnet_id" \
            $vnet_cx_json)
    # Optionally, modify properties for the connection
    # vnet_cx_json_string=$(echo $vnet_cx_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.labels = ["red"]')
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    new_assrt_name=$3
    echo "Associating vnet $vnet_name to hub hub${hub_id}..."
    # PUT
    az rest --method put --uri $vhub_vnetcx_uri --body $vnet_cx_json_string >/dev/null
}

function disconnect_spoke {
    hub_id=$1
    spoke_id=$2
    # Variables
    if [[ "$hub_id" == "1" ]]
    then
        location=$location1
    else
        location=$location2
    fi
    vm_name=spoke${hub_id}${spoke_id}
    vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
    vhub_vnetcx_uri="${vhub_base_uri}/hubVirtualNetworkConnections/${vm_name}?api-version=$vwan_api_version"
    # DELETE
    echo "Deleting connection $vm_name..."
    az rest --method delete --uri $vhub_vnetcx_uri
}


###################
#      Help       #
###################

function get_help {
    echo "These functions are defined:"
    echo "Virtual hubs:"
    echo "  get_vhub [hub_name]: get JSON for all or one hub"
    echo "  get_vhub_state [hub_name]: get state of all or one hub"
    echo "  reset_vhub <hub_name>: resends hub config"
    echo "Virtual network connections:"
    echo "  get_vnetcx_state <hub_name> [cx_name]: JSON for all or one connections in a hub"
    echo "  get_vnetcx <hub_name> [cx_name]: state of all or one connections in a hub"
    echo "  get_cx_labels <hub_name> <cx_name>: get labels of a vnet connection"
    echo "  cx_set_ass_rt <gw_name> <cx_name> rt1: sets associated RT for a connection"
    echo "  cx_set_prop_rt <gw_name> <cx_name> <rt1,rt2>: sets propagation RT IDs for a connection"
    echo "  cx_set_rt <hub_name> <cx_name> <associated_rt> <prop_rt1,prop_rt2>: sets routing config in cx"
    echo "  cx_add_routes <hub_name> <cx_name> <prefix> <next_hop>: adds a static route to a connection"
    echo "  cx_delete_routes <hub_name> <cx_name>: deletes all static routes"
    echo "  cx_set_prop_labels <hub_name> <cx_name> <label1,label2>: sets propagation labels for a connection"
    echo "  cx_delete_labels <hub_name> <cx_name>: deletes all propagating labels"
    echo "  reset_vhub_cx <hub_name> <cx_name>: resends vnet connection config"
    echo "Route tables:"
    echo "  create_rt <hub_name> <rt_name>: creates a route table"
    echo "  get_rt <hub_name> [rt_name]: JSON for all or one route table"
    echo "  get_rt_state <hub_name> [rt_name]: state for all or one route table"
    echo "  get_rt_labels <hub_name> <rt_name>: get labels for a route table"
    echo "  rt_add_routes <hub_name> <cx_name> <prefix> <next_hop>: adds a static route to a route table"
    echo "  rt_delete_routes <hub_name> <rt_name>: deletes all static routes in a route table"
    echo "  rt_add_label <hub_name> <rt_name> <label>"
    echo "  delete_rt_labels <hub_name> <rt_name>: delete all labels of a route table"
    echo "  delete_rt <hub_name> <rt_name>: deletes a route table"
    echo "VPN gateways:"
    echo "  get_vpngw [gw_name]: JSON for all or one VPN gateway"
    echo "  get_vpngw_state: state of vpn gateways"
    echo "VPN connections:"
    echo "  get_vpngw_cx <gw_name> [site_name]: get JSON for all or one connections of a VPN gateway"
    echo "  get_vpngw_cx_state <gw_name>: get state for all or one connections of a VPN gateway"
    echo "  get_vpncx_routing <gw_name>: get routing config for all or one connections of a VPN gateway"
    echo "  get_vpncx_labels <gw_name> <cx_name>: get labels for a connections of a VPN gateway"
    echo "  vpncx_set_prop_rt <gw_name> <cx_name> <rt1,rt2>: sets propagation labels for a connection"
    echo "  vpncx_set_prop_labels <gw_name> <cx_name> <label1,label2>: sets propagation labels for a connection"
    echo "Summary:"
    echo "  labels: prints label configuration for all connections and route tables"
    echo "  routing: prints routing configuration for all connections and route tables"
    echo "Firewall logs:"
    echo "  get_fw_logs_net: shows network rule logs"
    echo "  get_fw_logs_app: shows app rule logs"
    echo "Maintenance:"
    echo "  stop_vms: stops all CSRs, jump hosts and test vms"
    echo "  start_vms: starts all CSRs, jump hosts and test vms"
    echo "  get_ips: get public IP addresses of jump hosts and CSRs"
}

###################
# RG, VWAN, vHubs #
###################

# RG
az group create -n $rg -l $location1

# vwan
# https://docs.microsoft.com/en-us/rest/api/virtualwan/virtualwans/createorupdate
# az network vwan create -n $vwan -g $rg -l $location1 --branch-to-branch-traffic true --vnet-to-vnet-traffic true
vwan_json_string=$(jq -n \
    --arg location "$location1" \
    --arg sku "Standard" \
    $vwan_json)
az rest --method put --uri $vwan_uri --body $vwan_json_string
vwan_id=$(az network vwan show -n $vwan -g $rg --query id -o tsv) && echo $vwan_id

# hub1
# https://docs.microsoft.com/en-us/rest/api/virtualwan/virtualhubs/createorupdate
# az network vhub create -n hub1 -g $rg --vwan $vwan -l $location1 --address-prefix $vwan_hub1_prefix --sku Standard
vhub1_json_string=$(jq -n \
    --arg location "$location1" \
    --arg vwan_id $vwan_id \
    --arg sku "Standard" \
    --arg hub_prefix $vwan_hub1_prefix \
    $vhub_json)
az rest --method put --uri $vhub1_uri --body $vhub1_json_string    # PUT
# az rest --method get --uri $vhub1_uri                            # GET
# az rest --method delete --uri $vhub1_uri                         # DELETE

# hub2
# az network vhub create -n hub2 -g $rg --vwan $vwan -l $location2 --address-prefix $vwan_hub2_prefix --sku Standard
vhub2_json_string=$(jq -n \
    --arg location "$location2" \
    --arg vwan_id $vwan_id \
    --arg sku "Standard" \
    --arg hub_prefix $vwan_hub2_prefix \
    $vhub_json)
az rest --method put --uri $vhub2_uri --body $vhub2_json_string                                   # PUT
# az rest --method get --uri $vhub2_uri | jq                                                      # GET
# az rest --method get --uri $vhubs_uri | jq '.value[] | .name,.properties.provisioningState'     # GET
# az rest --method delete --uri $vhub2_uri                                                        # DELETE

####################
# S2S VPN Branches #
####################

# Branch 1 CSR
az vm create -n branch1-nva -g $rg -l $location1 --image ${publisher}:${offer}:${sku}:${version} --size $nva_size \
    --admin-username "$username" --generate-ssh-keys --public-ip-address branch1-pip --public-ip-address-allocation static \
    --vnet-name branch1 --vnet-address-prefix $branch1_prefix --subnet nva --subnet-address-prefix $branch1_subnet --private-ip-address $branch1_bgp_ip --no-wait
sleep 5 # Wait 5 seconds for the creation of the PIP
branch1_ip=$(az network public-ip show -n branch1-pip -g $rg --query ipAddress -o tsv) && echo $branch1_ip

# vpn site branch1
# az network vpn-site create -n branch1 -g $rg -l $location1 --virtual-wan $vwan --asn $branch1_asn --bgp-peering-address $branch1_bgp_ip --ip-address $branch1_ip --address-prefixes ${branch1_ip}/32 --device-vendor cisco --device-model csr --link-speed 100
# https://docs.microsoft.com/en-us/rest/api/virtualwan/vpnsites/createorupdate
# Note that changing IsSecuritySite' flag is not supported after creation time
# IsSecuritySite allows to advertise a 0.0.0.0/0??
vpnsite1_json_string=$(jq -n \
        --arg location "$location1" \
        --arg link_name "branch1" \
        --arg vwan_id $vwan_id \
        --arg remote_bgp_ip $branch1_bgp_ip \
        --arg remote_asn $branch1_asn \
        --arg remote_pip $branch1_ip \
        --arg site_prefix ${branch1_ip}/32 \
        --arg security 'false' \
        $vpnsite_json)
az rest --method put --uri $vpnsite1_uri --body $vpnsite1_json_string  # PUT
# az rest --method get --uri $vpnsite1_uri                             # GET
# az rest --method delete --uri $vpnsite1_uri                          # DELETE

# vpn gateway hub1
# az network vpn-gateway create -n hubvpn1 -g $rg -l $location1 --vhub hub1 --asn $vwan_hub1_asn
# https://docs.microsoft.com/en-us/rest/api/virtualwan/vpngateways/createorupdate
vhub1_id=$(az network vhub show -n hub1 -g $rg --query id -o tsv)
# az rest --method get --uri $vhubs_uri | jq '.value[] | .name,.properties.provisioningState'       # WAIT UNTIL HUB1 is Succeeded
wait_until_finished $vhub1_id
# vpnlink_json='{name: link1, properties: {vpnSiteLink: }}'
# vpnconn_json='{name: "conn1", properties: {remoteVpnSite: {id: $vpnsite_id}, vpnLinkConnections: [' $vpnlink_json ']}}'
vpngw1_json_string=$(jq -n \
        --arg location "$location1" \
        --arg vhub_id $vhub1_id \
        --arg asn $vwan_hub1_asn \
        $vpngw_json)
az rest --method put --uri $vpngw1_uri --body $vpngw1_json_string   # PUT
# az rest --method get --uri $vpngw1_uri                            # GET

# Branch 2 CSR
az vm create -n branch2-nva -g $rg -l $location2 --image ${publisher}:${offer}:${sku}:${version} \
    --admin-username "$username" --generate-ssh-keys --public-ip-address branch2-pip \
    --public-ip-address-allocation static --vnet-name branch2 --vnet-address-prefix $branch2_prefix \
    --subnet nva --subnet-address-prefix $branch2_subnet --private-ip-address $branch2_bgp_ip --no-wait
sleep 5 # Wait 5 seconds for the creation of the PIP
branch2_ip=$(az network public-ip show -n branch2-pip -g $rg --query ipAddress -o tsv) && echo $branch2_ip

# VPN site branch2
# isSecuritySite set to true for testing (so that it can be compared to sites 1 and 3)
vpnsite2_json_string=$(jq -n \
        --arg location "$location2" \
        --arg link_name "branch2" \
        --arg vwan_id $vwan_id \
        --arg remote_bgp_ip $branch2_bgp_ip \
        --arg remote_asn $branch2_asn \
        --arg remote_pip $branch2_ip \
        --arg site_prefix ${branch2_ip}/32 \
        --arg security 'true' \
        $vpnsite_json)
az rest --method put --uri $vpnsite2_uri --body $vpnsite2_json_string  # PUT
# az rest --method get --uri $vpnsite2_uri                             # GET
# az rest --method delete --uri $vpnsite2_uri                          # DELETE

# VPN GW hub2
vhub2_id=$(az network vhub show -n hub2 -g $rg --query id -o tsv)
wait_until_finished $vhub2_id
vpngw2_json_string=$(jq -n \
        --arg location "$location2" \
        --arg vhub_id $vhub2_id \
        --arg asn $vwan_hub2_asn \
        $vpngw_json)
az rest --method put --uri $vpngw2_uri --body $vpngw2_json_string  # PUT
# az rest --method get --uri $vpngw2_uri                           # GET
# az rest --method delete --uri $vpngw2_uri                        # DELETE

# vpn connection hub1-branch1
# az network vpn-gateway connection create -n branch1 --gateway-name hubvpn1 -g $rg --remote-vpn-site branch1 --enable-bgp true --protocol-type IKEv2 --shared-key "$password" --connection-bandwidth 100 --routing-weight 10 --internet-security true
# https://docs.microsoft.com/en-us/rest/api/virtualwan/vpnconnections/createorupdate
site1_id=$(az network vpn-site show -n branch1 -g $rg --query id -o tsv)
site1_link_id=$(az rest --method get --uri $vpnsite1_uri | jq -r '.properties.vpnSiteLinks[0].id')
vpngw1_id=$(az network vpn-gateway show -n hubvpn1 -g $rg --query id -o tsv)
wait_until_finished $vpngw1_id
vpncx1_json_string=$(jq -n \
        --arg cx_name "branch1" \
        --arg site_id "$site1_id" \
        --arg site_link_id $site1_link_id \
        --arg psk $password \
        $vpncx_json)
# Optional: configure some additional attributes:
# hub_name=hub1
# rt1_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub1/hubRouteTables/hub1NvaRouteTable
# rt2_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub2/hubRouteTables/hub2NvaRouteTable
# rt3_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/hub1BlueRT
# rt4_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/commonRouteTable
# vpncx1_json_string=$(echo $vpncx1_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.ids = [{"id": "'$rt1_id'"}, {"id": "'$rt2_id'"}]')
# Send JSON
az rest --method put --uri $vpngw1_cx1_uri --body $vpncx1_json_string    # PUT
# az rest --method get --uri $vpngw1_cx1_uri                             # GET

# Connection hub2-branch2
site2_id=$(az network vpn-site show -n branch2 -g $rg --query id -o tsv)
site2_link_id=$(az rest --method get --uri $vpnsite2_uri | jq -r '.properties.vpnSiteLinks[0].id')
vpngw2_id=$(az network vpn-gateway show -n hubvpn2 -g $rg --query id -o tsv)
wait_until_finished $vpngw2_id
vpncx2_json_string=$(jq -n \
        --arg cx_name "branch2" \
        --arg site_id "$site2_id" \
        --arg site_link_id $site2_link_id \
        --arg psk $password \
        $vpncx_json)
# Optional: configure some additional attributes:
# rt1_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub1/hubRouteTables/hub1NvaRouteTable
# rt2_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub2/hubRouteTables/hub2NvaRouteTable
# rt3_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/hub1BlueRT
# rt4_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/commonRouteTable
# vpncx2_json_string=$(echo $vpncx2_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.ids = [{"id": "'$rt1_id'"}, {"id": "'$rt2_id'"}]')
# Send PUT
az rest --method put --uri $vpngw2_cx2_uri --body $vpncx2_json_string  # PUT
# az rest --method get --uri $vpngw2_cx2_uri                           # GET
# az rest --method delete --uri $vpngw2_cx2_uri                        # DELETE

# Branch 3 CSR
az vm create -n branch3-nva -g $rg -l $location2 --image ${publisher}:${offer}:${sku}:${version} \
    --admin-username "$username" --generate-ssh-keys --public-ip-address branch3-pip \
    --public-ip-address-allocation static --vnet-name branch3 --vnet-address-prefix $branch3_prefix \
    --subnet nva --subnet-address-prefix $branch3_subnet --private-ip-address $branch3_bgp_ip --no-wait
sleep 5 # To give time for PIP creation
branch3_ip=$(az network public-ip show -n branch3-pip -g $rg --query ipAddress -o tsv) && echo $branch3_ip

# VPN site branch3
vpnsite3_json_string=$(jq -n \
        --arg location "$location2" \
        --arg link_name "branch3" \
        --arg vwan_id $vwan_id \
        --arg remote_bgp_ip $branch3_bgp_ip \
        --arg remote_asn $branch3_asn \
        --arg remote_pip $branch3_ip \
        --arg site_prefix ${branch3_ip}/32 \
        --arg security 'false' \
        $vpnsite_json)
az rest --method put --uri $vpnsite3_uri --body $vpnsite3_json_string   # PUT
# az rest --method get --uri $vpnsite3_uri                              # GET
# az rest --method delete --uri $vpnsite3_uri                           # DELETE

# Connection hub2-branch3
site3_id=$(az network vpn-site show -n branch3 -g $rg --query id -o tsv)
site3_link_id=$(az rest --method get --uri $vpnsite3_uri | jq -r '.properties.vpnSiteLinks[0].id')
vpncx3_json_string=$(jq -n \
        --arg cx_name "branch3" \
        --arg site_id "$site3_id" \
        --arg site_link_id $site3_link_id \
        --arg psk $password \
        $vpncx_json)
# Optional: configure some additional attributes:
# rt1_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub1/hubRouteTables/hub1NvaRouteTable
# rt2_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub2/hubRouteTables/hub2NvaRouteTable
# rt3_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/hub1BlueRT
# rt4_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/commonRouteTable
# vpncx3_json_string=$(echo $vpncx3_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.ids = [{"id": "'$rt1_id'"}, {"id": "'$rt2_id'"}]')
# Send PUT
az rest --method put --uri $vpngw2_cx3_uri --body $vpncx3_json_string    # PUT
# az rest --method get --uri $vpngw2_cx3_uri                             # GET
# az rest --method delete --uri $vpngw2_cx3_uri                          # DELETE

# Add public key of CSRs to known_hosts
rm ~/.ssh/known_hosts
ssh-keyscan -H $branch1_ip >> ~/.ssh/known_hosts
ssh-keyscan -H $branch2_ip >> ~/.ssh/known_hosts
ssh-keyscan -H $branch3_ip >> ~/.ssh/known_hosts

#################
#     Vnets     #
#################

# hub1
create_spokes 1 5 # Creates 5 spokes in $location1
# connect_spoke 1 1
# wait_until_hub_finished hub1
# connect_spoke 1 2
# wait_until_hub_finished hub1
# connect_spoke 1 3
# wait_until_hub_finished hub1
# connect_spoke 1 4
# wait_until_hub_finished hub1
# connect_spoke 1 5  # Spoke 5 will be behind an NVA vnet, aka "user hub"
# ** Diagnostics **
# get_vhub_state hub1
# get_vnetcx_state hub1
# reset_vhub hub1

# hub 2
create_spokes 2 5 # Creates 5 spokes in $location2
connect_spoke 2 1
wait_until_hub_finished hub2
connect_spoke 2 2
wait_until_hub_finished hub2
connect_spoke 2 3
wait_until_hub_finished hub2
connect_spoke 2 4
wait_until_hub_finished hub2
connect_spoke 2 5  # Spoke 5 will be behind an NVA vnet, aka "user hub"
# ** Diagnostics **
# get_vhub_state hub2
# get_vnetcx_state hub2
# reset_vhub hub2

#################
#   User hubs   #
#################
# (aka NVA vnets)

# User hub 1
az vm create -n azure-nva1 -g $rg -l $location1 --image ubuntuLTS \
    --admin-username $username --generate-ssh-keys \
    --public-ip-address userhub1-pip --public-ip-address-allocation static \
    --vnet-name userhub-$location1 --vnet-address-prefix $user_hub1_prefix \
    --subnet nva --subnet-address-prefix $user_hub1_subnet \
    --private-ip-address $user_hub1_nva_ip --no-wait
# Az FW in hub 1 (optional)
az network vnet subnet create -n AzureFirewallSubnet --vnet-name userhub-$location1 -g $rg --address-prefixes $user_hub1_fw_subnet
az network public-ip create -g $rg -n userfw1_pip --sku standard --allocation-method static -l $location1
az network firewall create -n userfw1 -g $rg -l $location1
az network firewall ip-config create -f userfw1 -n userfw1-ipconfig -g $rg --public-ip-address userfw1_pip --vnet-name userhub-$location1
userfw1_private_ip=$(az network firewall show -n userfw1 -g $rg -o tsv --query 'ipConfigurations[0].privateIpAddress') && echo $userfw1_private_ip
az network route-table route create -n default --route-table-name jumphost-$location1 -g $rg \
    --next-hop-type VirtualAppliance --address-prefix 0.0.0.0/0 --next-hop-ip-address $userfw1_private_ip
# Peerings
# sleep 30  # Wait 30 seconds for the creation of the vnets, so that we can configure the peerings
az network vnet peering create -n spoke11tohub -g $rg --vnet-name spoke11-$location1 --remote-vnet userhub-$location1 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n hubtospoke11 -g $rg --vnet-name userhub-$location1 --remote-vnet spoke11-$location1 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n spoke12tohub -g $rg --vnet-name spoke12-$location1 --remote-vnet userhub-$location1 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n hubtospoke12 -g $rg --vnet-name userhub-$location1 --remote-vnet spoke12-$location1 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n spoke15tohub -g $rg --vnet-name spoke15-$location1 --remote-vnet userhub-$location1 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n hubtospoke15 -g $rg --vnet-name userhub-$location1 --remote-vnet spoke15-$location1 --allow-vnet-access --allow-forwarded-traffic
# az network vhub connection create -n tohub -g $rg --vhub-name hub1 --remote-vnet hub-$location1 --remote-vnet-transit true --use-hub-vnet-gateways true --internet-security true
# UDR
az network route-table create -n spokes-$location1 -g $rg -l $location1 --disable-bgp-route-propagation
az network route-table route create -n default -g $rg --route-table-name spokes-$location1 --address-prefix 0.0.0.0/0 --next-hop-type VirtualAppliance --next-hop-ip-address $user_hub1_nva_ip
mypip=$(curl -s4 ifconfig.co) && echo $mypip
az network route-table route create -n mypc -g $rg --route-table-name spokes-$location1 --address-prefix "${mypip}/32" --next-hop-type Internet
az network vnet subnet update -n vm --vnet-name spoke15-$location1 -g $rg --route-table spokes-$location1
az network vnet subnet update -n jumphost --vnet-name spoke15-$location1 -g $rg --route-table spokes-$location1
# IP forwarding
user_nva1_nic_id=$(az vm show -n azure-nva1 -g $rg --query 'networkProfile.networkInterfaces[0].id' -o tsv)
az network nic update --ids $user_nva1_nic_id --ip-forwarding
user_nva1_pip=$(az network public-ip show -n userhub1-pip -g $rg --query ipAddress -o tsv) && echo $user_nva1_pip
ssh-keyscan -H $user_nva1_pip >> ~/.ssh/known_hosts
ssh -n -o BatchMode=yes $user_nva1_pip "sudo sysctl -w net.ipv4.ip_forward=1"
# Connection to hub1
userhub1_vnet_id=$(az network vnet show -n userhub-$location1 -g $rg --query id -o tsv)
userhub1_cx_json_string=$(jq -n \
        --arg vnet_id "$userhub1_vnet_id" \
        $vnet_cx_json)
az rest --method put --uri $vhub1_vnetcxhub1_uri --body $userhub1_cx_json_string  # PUT
# az rest --method get --uri $vhub1_vnetcxhub1_uri                                # GET

# User hub 2
az vm create -n azure-nva2 -g $rg -l $location2 --image ubuntuLTS \
    --admin-username $username --generate-ssh-keys \
    --public-ip-address userhub2-pip --public-ip-address-allocation static \
    --vnet-name userhub-$location2 --vnet-address-prefix $user_hub2_prefix \
    --subnet nva --subnet-address-prefix $user_hub2_subnet \
    --private-ip-address $user_hub2_nva_ip --no-wait
# Az FW in hub 2 (optional)
az network vnet subnet create -n AzureFirewallSubnet --vnet-name userhub-$location2 -g $rg --address-prefixes $user_hub2_fw_subnet
az network public-ip create -g $rg -n userfw2_pip --sku standard --allocation-method static -l $location2
az network firewall create -n userfw2 -g $rg -l $location2
az network firewall ip-config create -f userfw2 -n userfw2-ipconfig -g $rg --public-ip-address userfw2_pip --vnet-name userhub-$location2
userfw1_private_ip=$(az network firewall show -n userfw1 -g $rg -o tsv --query 'ipConfigurations[0].privateIpAddress') && echo $userfw1_private_ip
az network route-table route create -n default --route-table-name jumphost-$location1 -g $rg \
    --next-hop-type VirtualAppliance --address-prefix 0.0.0.0/0 --next-hop-ip-address $userfw1_private_ip
userfw2_private_ip=$(az network firewall show -n userfw2 -g $rg -o tsv --query 'ipConfigurations[0].privateIpAddress') && echo $userfw2_private_ip
az network route-table route create -n default --route-table-name jumphost-$location2 -g $rg \
    --next-hop-type VirtualAppliance --address-prefix 0.0.0.0/0 --next-hop-ip-address $userfw2_private_ip
# Peerings
# sleep 30  # Wait 30 seconds for the creation of the vnets, so that we can configure the peerings
az network vnet peering create -n spoke21tohub -g $rg --vnet-name spoke21-$location2 --remote-vnet userhub-$location2 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n hubtospoke21 -g $rg --vnet-name userhub-$location2 --remote-vnet spoke21-$location2 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n spoke22tohub -g $rg --vnet-name spoke22-$location2 --remote-vnet userhub-$location2 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n hubtospoke22 -g $rg --vnet-name userhub-$location2 --remote-vnet spoke22-$location2 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n spoke23tohub -g $rg --vnet-name spoke23-$location2 --remote-vnet userhub-$location2 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n hubtospoke23 -g $rg --vnet-name userhub-$location2 --remote-vnet spoke23-$location2 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n spoke25tohub -g $rg --vnet-name spoke25-$location2 --remote-vnet userhub-$location2 --allow-vnet-access --allow-forwarded-traffic
az network vnet peering create -n hubtospoke25 -g $rg --vnet-name userhub-$location2 --remote-vnet spoke25-$location2 --allow-vnet-access --allow-forwarded-traffic
# UDR
mypip=$(curl -s4 ifconfig.co) && echo $mypip
az network route-table create -n spokes-$location2 -g $rg -l $location2 --disable-bgp-route-propagation
az network route-table route create -n default -g $rg --route-table-name spokes-$location2 --address-prefix 0.0.0.0/0 --next-hop-type VirtualAppliance --next-hop-ip-address $user_hub2_nva_ip
az network route-table route create -n mypc -g $rg --route-table-name spokes-$location2 --address-prefix "${mypip}/32" --next-hop-type Internet
# az network vnet subnet update -n vm --vnet-name spoke25-$location2 -g $rg --route-table spokes-$location2
az network vnet subnet update -n jumphost --vnet-name spoke25-$location2 -g $rg --route-table spokes-$location2
# IP forwarding
user_nva2_nic_id=$(az vm show -n azure-nva2 -g $rg --query 'networkProfile.networkInterfaces[0].id' -o tsv)
az network nic update --ids $user_nva2_nic_id --ip-forwarding
user_nva2_pip=$(az network public-ip show -n userhub2-pip -g $rg --query ipAddress -o tsv) && echo $user_nva2_pip
ssh-keyscan -H $user_nva2_pip >> ~/.ssh/known_hosts
ssh -n -o BatchMode=yes $user_nva1_pip "sudo sysctl -w net.ipv4.ip_forward=1"
# Connection to hub2
userhub2_vnet_id=$(az network vnet show -n userhub-$location2 -g $rg --query id -o tsv)
userhub2_cx_json_string=$(jq -n \
        --arg vnet_id "$userhub2_vnet_id" \
        $vnet_cx_json)
az rest --method put --uri $vhub2_vnetcxhub2_uri --body $userhub2_cx_json_string  # PUT
# az rest --method get --uri $vhub2_vnetcxhub2_uri                                # GET
# Delete spoke connections to hub1 - IF REQUIRED
# az rest --method delete --uri $vhub2_vnetcx3_uri
# az rest --method delete --uri $vhub2_vnetcx4_uri

# Add static routes to connection to userhub1
hub_name=hub1
cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
cx_json=$(az rest --method get --uri $cx_uri)
new_route_json_string=$(jq -n \
        --arg name "test" \
        --arg prefixes "10.1.5.0/24" \
        --arg nexthop "$user_hub1_nva_ip" \
        $cxroute_json)
cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes = ['$new_route_json_string'] | {name, properties}')
az rest --method put --uri $cx_uri --body $cx_json_updated  # PUT
az rest --method get --uri $cx_uri | jq -r '.properties.routingConfiguration.vnetRoutes.staticRoutes'  # GET
# Add static route to default RTs
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate#hubroute
hub_name=hub1
rt_name=defaultRouteTable
rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
rt_json_current=$(az rest --method get --uri $rt_uri)
userhub_cxid=$(az rest --method get --uri $cx_uri | jq -r '.id')
new_route_json_string=$(jq -n \
        --arg name "hub2spoke15" \
        --arg type "ResourceId" \
        --arg prefixes '10.1.5.0/24' \
        --arg nexthop "$userhub_cxid" \
        $route_json)
rt_json_updated=$(echo $rt_json_current | jq '.properties.routes += [ '$new_route_json_string' ] | {name, properties}')
az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
hub_name=hub2
rt_name=defaultRouteTable
rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
rt_json_current=$(az rest --method get --uri $rt_uri)
userhub_cxid=$(az rest --method get --uri $cx_uri | jq -r '.id')
new_route_json_string=$(jq -n \
        --arg name "hub2spoke15" \
        --arg type "ResourceId" \
        --arg prefixes '10.1.5.0/24' \
        --arg nexthop "$userhub_cxid" \
        $route_json)
rt_json_updated=$(echo $rt_json_current | jq '.properties.routes += [ '$new_route_json_string' ] | {name, properties}')
az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT

# Add static routes to connection to userhub2
hub_name=hub2
cx_name=userhub
cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
cx_json=$(az rest --method get --uri $cx_uri)
new_route_json_string=$(jq -n \
        --arg name "test" \
        --arg prefixes "10.2.5.0/24" \
        --arg nexthop "$user_hub2_nva_ip" \
        $cxroute_json)
cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes = ['$new_route_json_string'] | {name, properties}')
az rest --method put --uri $cx_uri --body $cx_json_updated  # PUT
az rest --method get --uri $cx_uri | jq -r '.properties.routingConfiguration.vnetRoutes.staticRoutes'  # GET
# Add static route to default RT
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate#hubroute
hub_name=hub1
rt_name=defaultRouteTable
rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
rt_json_current=$(az rest --method get --uri $rt_uri)
userhub_cxid=$(az rest --method get --uri $cx_uri | jq -r '.id')
new_route_json_string=$(jq -n \
        --arg name "hub2spoke25" \
        --arg type "ResourceId" \
        --arg prefixes '10.2.5.0/24' \
        --arg nexthop "$userhub_cxid" \
        $route_json)
rt_json_updated=$(echo $rt_json_current | jq '.properties.routes += [ '$new_route_json_string' ] | {name, properties}')
az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
hub_name=hub2
rt_name=defaultRouteTable
rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
rt_json_current=$(az rest --method get --uri $rt_uri)
userhub_cxid=$(az rest --method get --uri $cx_uri | jq -r '.id')
new_route_json_string=$(jq -n \
        --arg name "hub2spoke25" \
        --arg type "ResourceId" \
        --arg prefixes '10.2.5.0/24' \
        --arg nexthop "$userhub_cxid" \
        $route_json)
rt_json_updated=$(echo $rt_json_current | jq '.properties.routes += [ '$new_route_json_string' ] | {name, properties}')
az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
az rest --method get --uri $rt_uri | jq '.properties.routes'  # GET


##################
# Configure CSRs #
##################

# Option 1: get VPN Gateway data from file

# Download configuration
# Setting SAS
storage_account=vpnconfigs$RANDOM 
# storage_account=$(az storage account list -g $rg --query '[0].name' -o tsv)  # If storage account already created
storage_key=$(az storage account keys list --account-name $storage_account -g $rg --query '[0].value' -o tsv)
container_name=configs
blob_name=vpnconfig.json
file_name="/tmp/${blob_name}"
az storage account create -n $storage_account -g $rg -l $location1 --sku Standard_LRS
az storage container create -n $container_name --account-name $storage_account --auth-mode key --account-key "$storage_key"
# Create SAS and download config file for 3 branches
end_time=`date -u -d "240 minutes" '+%Y-%m-%dT%H:%MZ'`
sas=$(az storage container generate-sas -n $container_name --account-name $storage_account --permissions dlrw --expiry $end_time -o tsv)
account_url=$(az storage account show -n $storage_account -g $rg --query primaryEndpoints.blob -o tsv)
storage_url=${account_url}${container_name}"/"${blob_name}"?"${sas}
az network vpn-site download --vwan-name $vwan -g $rg --vpn-sites branch1 branch2 branch3 --output-blob-sas-url $storage_url
az storage blob download --account-name $storage_account -c $container_name -n $blob_name --sas-token $sas -f $file_name

# Extract info for branch1
site=branch1
branch1_psk=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].connectionConfiguration.PSK')
branch1_gw0_pip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.IpAddresses.Instance0')
branch1_gw1_pip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.IpAddresses.Instance1')
branch1_gw0_bgp_ip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.BgpSetting.BgpPeeringAddresses.Instance0')
branch1_gw1_bgp_ip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.BgpSetting.BgpPeeringAddresses.Instance1')
echo "Extracted info for $site: Gateway0 $branch1_gw0_pip, $branch1_gw0_bgp_ip. Gateway1 $branch1_gw1_pip, $branch1_gw0_bgp_ip. PSK $branch1_psk"

# Extract info for branch2
site=branch2
branch2_psk=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].connectionConfiguration.PSK')
branch2_gw0_pip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.IpAddresses.Instance0')
branch2_gw1_pip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.IpAddresses.Instance1')
branch2_gw0_bgp_ip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.BgpSetting.BgpPeeringAddresses.Instance0')
branch2_gw1_bgp_ip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.BgpSetting.BgpPeeringAddresses.Instance1')
echo "Extracted info for $site: Gateway0 $branch2_gw0_pip, $branch2_gw0_bgp_ip. Gateway1 $branch2_gw1_pip, $branch2_gw0_bgp_ip. PSK $branch2_psk"

# Extract info for branch3
site=branch3
branch3_psk=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].connectionConfiguration.PSK')
branch3_gw0_pip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.IpAddresses.Instance0')
branch3_gw1_pip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.IpAddresses.Instance1')
branch3_gw0_bgp_ip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.BgpSetting.BgpPeeringAddresses.Instance0')
branch3_gw1_bgp_ip=$(cat $file_name | jq -r '.[] | select (.vpnSiteConfiguration.Name == "'$site'") | .vpnSiteConnections[].gatewayConfiguration.BgpSetting.BgpPeeringAddresses.Instance1')
echo "Extracted info for $site: Gateway0 $branch3_gw0_pip, $branch3_gw0_bgp_ip. Gateway1 $branch3_gw1_pip, $branch3_gw0_bgp_ip. PSK $branch3_psk"

# Option 2: get VPN Gateway data from API

vpngw1=$(az rest --method get --uri $vpngw1_uri)
vpngw1_gw0_pip=$(echo $vpngw1 | jq -r '.properties.ipConfigurations[0].publicIpAddress')
vpngw1_gw1_pip=$(echo $vpngw1 | jq -r '.properties.ipConfigurations[1].publicIpAddress')
vpngw1_gw0_bgp_ip=$(echo $vpngw1 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[0].defaultBgpIpAddresses[0]')
vpngw1_gw1_bgp_ip=$(echo $vpngw1 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[1].defaultBgpIpAddresses[0]')
echo "Extracted info for vpngw1: Gateway0 $vpngw1_gw0_pip, $vpngw1_gw0_bgp_ip. Gateway1 $vpngw1_gw1_pip, $vpngw1_gw0_bgp_ip."
vpngw2=$(az rest --method get --uri $vpngw2_uri)
vpngw2_gw0_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[0].publicIpAddress')
vpngw2_gw1_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[1].publicIpAddress')
vpngw2_gw0_bgp_ip=$(echo $vpngw2 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[0].defaultBgpIpAddresses[0]')
vpngw2_gw1_bgp_ip=$(echo $vpngw2 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[1].defaultBgpIpAddresses[0]')
echo "Extracted info for vpngw2: Gateway0 $vpngw2_gw0_pip, $vpngw2_gw0_bgp_ip. Gateway1 $vpngw2_gw1_pip, $vpngw2_gw0_bgp_ip."
# branch1 to vpngw1, branch2/3 to vpngw2
branch1_gw0_pip=$vpngw1_gw0_pip
branch1_gw1_pip=$vpngw1_gw1_pip
branch1_gw0_bgp_ip=$vpngw1_gw0_bgp_ip
branch1_gw1_bgp_ip=$vpngw1_gw1_bgp_ip
branch1_psk=$password
branch2_gw0_pip=$vpngw2_gw0_pip
branch2_gw1_pip=$vpngw2_gw1_pip
branch2_gw0_bgp_ip=$vpngw2_gw0_bgp_ip
branch2_gw1_bgp_ip=$vpngw2_gw1_bgp_ip
branch2_psk=$password
branch3_gw0_pip=$vpngw2_gw0_pip
branch3_gw1_pip=$vpngw2_gw1_pip
branch3_gw0_bgp_ip=$vpngw2_gw0_bgp_ip
branch3_gw1_bgp_ip=$vpngw2_gw1_bgp_ip
branch3_psk=$password

# Create CSR config for branch 1
csr_config_url="https://raw.githubusercontent.com/erjosito/azure-wan-lab/master/csr_config_2tunnels_tokenized.txt"
config_file_csr='branch1_csr.cfg'
config_file_local='/tmp/branch1_csr.cfg'
wget $csr_config_url -O $config_file_local
sed -i "s|\*\*PSK\*\*|${branch1_psk}|g" $config_file_local
sed -i "s|\*\*GW0_Private_IP\*\*|${branch1_gw0_bgp_ip}|g" $config_file_local
sed -i "s|\*\*GW1_Private_IP\*\*|${branch1_gw1_bgp_ip}|g" $config_file_local
sed -i "s|\*\*GW0_Public_IP\*\*|${branch1_gw0_pip}|g" $config_file_local
sed -i "s|\*\*GW1_Public_IP\*\*|${branch1_gw1_pip}|g" $config_file_local
sed -i "s|\*\*BGP_ID\*\*|${branch1_asn}|g" $config_file_local
scp $config_file_local ${branch1_ip}:/${config_file_csr}
ssh -o BatchMode=yes $branch1_ip <<EOF
  config t
    file prompt quiet
EOF
ssh -n -o BatchMode=yes $branch1_ip "copy bootflash:${config_file_csr} running-config"
ssh -n -o BatchMode=yes $branch1_ip "wr mem"
ssh -n -o BatchMode=yes $branch1_ip "sh ip int b"
ssh -n -o BatchMode=yes $branch1_ip "sh ip bgp summary"
ssh -n -o BatchMode=yes $branch1_ip "sh ip route bgp"

# Create CSR config for branch 2
# If you are going to cross-connect branch2 to both hubs, you want to skip this and go to the 4-tunnel config
csr_config_url="https://raw.githubusercontent.com/erjosito/azure-wan-lab/master/csr_config_2tunnels_tokenized.txt"
config_file_csr='branch2_csr.cfg'
config_file_local='/tmp/branch2_csr.cfg'
wget $csr_config_url -O $config_file_local
sed -i "s|\*\*PSK\*\*|${branch2_psk}|g" $config_file_local
sed -i "s|\*\*GW0_Private_IP\*\*|${branch2_gw0_bgp_ip}|g" $config_file_local
sed -i "s|\*\*GW1_Private_IP\*\*|${branch2_gw1_bgp_ip}|g" $config_file_local
sed -i "s|\*\*GW0_Public_IP\*\*|${branch2_gw0_pip}|g" $config_file_local
sed -i "s|\*\*GW1_Public_IP\*\*|${branch2_gw1_pip}|g" $config_file_local
sed -i "s|\*\*BGP_ID\*\*|${branch2_asn}|g" $config_file_local
scp $config_file_local ${branch2_ip}:/${config_file_csr}
ssh -o BatchMode=yes $branch2_ip <<EOF
  config t
    file prompt quiet
EOF
ssh -n -o BatchMode=yes $branch2_ip "copy bootflash:${config_file_csr} running-config"
ssh -n -o BatchMode=yes $branch2_ip "wr mem"
ssh -n -o BatchMode=yes $branch2_ip "sh ip int b"
ssh -n -o BatchMode=yes $branch2_ip "sh ip bgp summary"
ssh -n -o BatchMode=yes $branch2_ip "sh ip route bgp"

# Create CSR config for branch 3
# If you are going to cross-connect branch2 to both hubs, you want to skip this and go to the 4-tunnel config
csr_config_url="https://raw.githubusercontent.com/erjosito/azure-wan-lab/master/csr_config_2tunnels_tokenized.txt"
config_file_csr='branch3_csr.cfg'
config_file_local='/tmp/branch3_csr.cfg'
wget $csr_config_url -O $config_file_local
sed -i "s|\*\*PSK\*\*|${branch2_psk}|g" $config_file_local
sed -i "s|\*\*GW0_Private_IP\*\*|${branch3_gw0_bgp_ip}|g" $config_file_local
sed -i "s|\*\*GW1_Private_IP\*\*|${branch3_gw1_bgp_ip}|g" $config_file_local
sed -i "s|\*\*GW0_Public_IP\*\*|${branch3_gw0_pip}|g" $config_file_local
sed -i "s|\*\*GW1_Public_IP\*\*|${branch3_gw1_pip}|g" $config_file_local
sed -i "s|\*\*BGP_ID\*\*|${branch3_asn}|g" $config_file_local
scp $config_file_local ${branch3_ip}:/${config_file_csr}
ssh -o BatchMode=yes $branch3_ip <<EOF
  config t
    file prompt quiet
EOF
ssh -n -o BatchMode=yes $branch3_ip "copy bootflash:${config_file_csr} running-config"
ssh -n -o BatchMode=yes $branch3_ip "wr mem"
ssh -n -o BatchMode=yes $branch3_ip "sh ip int b"
ssh -n -o BatchMode=yes $branch3_ip "sh ip bgp summary"
ssh -n -o BatchMode=yes $branch3_ip "sh ip route bgp"

# Additional CSR config (optional)

# redistribute connected
for id (1 2 3)
do
    eval "branch_ip=\"\${branch${id}_ip}\""
    echo "Configuring CSR with IP ${branch_ip}..."
    ssh -o BatchMode=yes $branch_ip <<EOF
    config t
        router bgp 6550$id
            redistribute connected
        end
    clear ip bgp *
    wr mem
EOF
done

#################
# Log Analytics #
#################

# See https://docs.microsoft.com/azure/virtual-wan/logs-metrics

az monitor log-analytics workspace create -n $logws_name -g $rg
logws_id=$(az resource list -g $rg -n $logws_name --query '[].id' -o tsv)
hub1_vpngw_id=$(az network vpn-gateway show -n hubvpn1 -g $rg --query id -o tsv)
hub2_vpngw_id=$(az network vpn-gateway show -n hubvpn2 -g $rg --query id -o tsv)
az monitor diagnostic-settings create -n mydiag --resource $hub1_vpngw_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "GatewayDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "TunnelDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "RouteDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "IKEDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]' >/dev/null
az monitor diagnostic-settings create -n mydiag --resource $hub2_vpngw_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "GatewayDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "TunnelDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "RouteDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "IKEDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]' >/dev/null

######################
# Connectivity tests #
######################

get_ips

# Test connectivity to jump host
ssh -n -o BatchMode=yes $spoke11_jump_pip "ip a"
# spoke to Internet (local vhub)
ssh -n -o BatchMode=yes $spoke11_jump_pip "curl -s4 http://ifconfig.co"
ssh -n -o BatchMode=yes $spoke11_jump_pip "curl -s4 http://api.ipify.org"
# Jump host to spoke vm (intra-vnet)
ssh -n -o BatchMode=yes $spoke11_jump_pip "ping $spoke1_vm_ip -c 3"
# spoke1 to spoke2 (local vhub)
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke1_vm_ip "ping $spoke2_vm_ip -c 3"
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke1_vm_ip "nc -vz $spoke3_vm_ip 22"
# spoke1 to spoke3 (remote vhub)
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke11_vm_ip "ping $spoke3_vm_ip -c 3"
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke11_vm_ip "nc -vz $spoke3_vm_ip 22"
# Connectivity to branch1 (local vhub)
ssh -n -o BatchMode=yes $spoke1_jump_pip "ping $branch1_bgp_ip -c 3"
ssh -n -o BatchMode=yes $spoke1_jump_pip "nc -vz $branch1_bgp_ip 22"
# Connectivity to branch2 (remote vhub)
ssh -n -o BatchMode=yes $spoke1_jump_pip "ping $branch2_bgp_ip -c 3"
ssh -n -o BatchMode=yes $spoke1_jump_pip "nc -vz $branch2_bgp_ip 22"
# BGP info in branch1
ssh -n -o BatchMode=yes $branch1_ip "show ip bgp summary"
ssh -n -o BatchMode=yes $branch1_ip "show ip route"
ssh -n -o BatchMode=yes $branch1_ip "show ip route bgp"
# BGP routes in branch2
ssh -n -o BatchMode=yes $branch2_ip "show ip bgp summary"
ssh -n -o BatchMode=yes $branch2_ip "show ip route"
ssh -n -o BatchMode=yes $branch2_ip "show ip route bgp"
# Branch to branch
ssh -n -o BatchMode=yes $branch1_ip "ping $branch2_bgp_ip"

###############
# Secured hub #
###############

# Enable/disable secured vnet connections (enables 0/0 propagation, but doesnt actually inject it)
# az network vhub connection create -n tospoke1 -g $rg --remote-vnet spoke1-$location1 --vhub-name hub1 --remote-vnet-transit true --use-hub-vnet-gateways true --internet-security true
# az network vhub connection create -n tospoke2 -g $rg --remote-vnet spoke3-$location2 --vhub-name hub2 --remote-vnet-transit true --use-hub-vnet-gateways true --internet-security true
# az network vpn-gateway connection create -n branch1 --gateway-name hubvpn1 -g $rg --remote-vpn-site branch1 --enable-bgp true --protocol-type IKEv2 --shared-key "$password" --connection-bandwidth 100 --routing-weight 10 --internet-security true
# az network vpn-gateway connection create -n branch2 --gateway-name hubvpn2 -g $rg --remote-vpn-site branch2 --enable-bgp true --protocol-type IKEv2 --shared-key "$password" --connection-bandwidth 100 --routing-weight 10 --internet-security true

# Firewall policy
az network firewall policy create -n myfwpolicy -g $rg
az network firewall policy rule-collection-group create -n ruleset01 --policy-name myfwpolicy -g $rg --priority 100
# Example network collections
az network firewall policy rule-collection-group collection add-filter-collection --policy-name myfwpolicy --rule-collection-group-name ruleset01 -g $rg \
    --name filter01 --collection-priority 101 --action Allow --rule-name allowSSH --rule-type NetworkRule --description "TCP 22" \
    --destination-addresses "10.0.0.0/8" --source-addresses "10.0.0.0/8" --ip-protocols TCP --destination-ports 22
az network firewall policy rule-collection-group collection add-filter-collection --policy-name myfwpolicy --rule-collection-group-name ruleset01 -g $rg \
    --name filter02 --collection-priority 102 --action Allow --rule-name allowICMP --rule-type NetworkRule --description "ICMP traffic" \
    --destination-addresses "10.0.0.0/8" --source-addresses "10.0.0.0/8" --ip-protocols ICMP --destination-ports "1-65535"
az network firewall policy rule-collection-group collection add-filter-collection --policy-name myfwpolicy --rule-collection-group-name ruleset01 -g $rg \
    --name ntp --collection-priority 103 --action Allow --rule-name allowNTP --rule-type NetworkRule --description "ICMP traffic" \
    --destination-addresses "10.0.0.0/8" --source-addresses "0.0.0.0/0" --ip-protocols UDP --destination-ports "123"
# Example application collection with 2 rules
az network firewall policy rule-collection-group collection add-filter-collection --policy-name myfwpolicy --rule-collection-group-name ruleset01 -g $rg \
    --name ifconfig --collection-priority 201 --action Allow --rule-name allowIfconfig --rule-type ApplicationRule --description "ifconfig" \
    --target-fqdns "ifconfig.co" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443
az network firewall policy rule-collection-group collection rule add -g $rg --policy-name myfwpolicy --rule-collection-group-name ruleset01 --collection-name ifconfig \
    --name ipify --target-fqdns "api.ipify.org" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443 --rule-type ApplicationRule
# Example application collection with wildcards
az network firewall policy rule-collection-group collection add-filter-collection --policy-name myfwpolicy --rule-collection-group-name ruleset01 -g $rg \
    --name ubuntu --collection-priority 202 --action Allow --rule-name repos --rule-type ApplicationRule --description "ubuntucom" \
    --target-fqdns "*.ubuntu.com" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443
# Example deleting rules
# az network firewall policy rule-collection-group collection remove --policy-name myfwpolicy --rule-collection-group-name ruleset01 -g $rg

# Azure Firewalls
az network firewall create -n azfw1 -g $rg --vhub hub1 --policy myfwpolicy -l $location1 --sku AZFW_Hub --public-ip-count 1
az network firewall create -n azfw2 -g $rg --vhub hub2 --policy myfwpolicy -l $location2 --sku AZFW_Hub --public-ip-count 1

# Diagnostics
azfw1_id=$(az network firewall show -n azfw1 -g $rg -o tsv --query id)
azfw2_id=$(az network firewall show -n azfw2 -g $rg -o tsv --query id)
# azfw1_id=$(az network firewall show -n userfw1 -g $rg -o tsv --query id)
# azfw2_id=$(az network firewall show -n userfw2 -g $rg -o tsv --query id)
az monitor diagnostic-settings create -n mydiag --resource $azfw1_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "AzureFirewallApplicationRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "AzureFirewallNetworkRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]'
az monitor diagnostic-settings create -n mydiag --resource $azfw2_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "AzureFirewallApplicationRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "AzureFirewallNetworkRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]'

#######################
# FW Mgr - RTv2 (old) #
#######################

# Routes in vhub (using the same route table names that the portal generates)
# This is the route for "Traffic for Virtual Networks" and will inject the default in the vnet
# The route injected by the protal has as next hop .132 instead of .68????
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs1_ip
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs2_ip
# This is the route for "Traffic for Branches" and will inject the default in the vnet
# However, the route doesnt appear to be advertised over BGP
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs1_ip
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs2_ip
# This is the route updates introduced by "Traffic between vnets via Azure Firewall"
# ...excluding the 0/0 for branches
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw1_ip \
    --destinations "0.0.0.0/0" $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw1_ip \
    --destinations $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 
az network vhub route-table delete -n VirtualNetworkRouteTable -g $rg --vhub-name hub2
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw2_ip \
    --destinations "0.0.0.0/0" $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 
az network vhub route-table delete -n BranchRouteTable -g $rg --vhub-name hub2
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw2_ip \
    --destinations $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 

# If route-tables need to be deleted:
# az network vhub route-table delete -n VnetRouteTable -g $rg --vhub-name hub1
# az network vhub route-table delete -n VnetRouteTable -g $rg --vhub-name hub2

##################
# Red/Blue vnets #
##################

# hub1
create_rt hub1 hub1RedRT
rt_add_label hub1 hub1RedRT red
# Verify:
#   get_vhub_state hub1
#   get_rt_state hub1 hub1RedRT
#   get_rt hub1 hub1RedRT
# Reset:
#   reset_rt hub1 hub1RedRT
# Delete
#   delete_rt hub1 hub1RedRT
wait_until_hub_finished hub1
create_rt hub1 hub1BlueRT
wait_until_hub_finished hub1
rt_add_label hub1 hub1BlueRT blue
cx_set_rt hub1 spoke11 hub1RedRT hub1RedRT,hub1CSRT,defaultRouteTable
# Verify:
#   get_vhub_state hub1
#   get_vnetcx_state hub1 spoke1
#   get_vnetcx hub1 spoke1
wait_until_hub_finished hub1
cx_set_rt hub1 spoke12 hub1RedRT hub1RedRT,hub1CSRT,defaultRouteTable
wait_until_hub_finished hub1
cx_set_rt hub1 spoke13 hub1BlueRT hub1BlueRT,hub1CSRT,defaultRouteTable
wait_until_hub_finished hub1
cx_set_rt hub1 spoke14 hub1CSRT hub1RedRT,hub1BlueRT,hub1CSRT,defaultRouteTable
# Verify:
#   get_vhub_state hub1
#   get_vnetcx_state hub1 spoke2
#   get_vnetcx hub1 spoke2

# hub2
create_rt hub2 hub2RedRT
wait_until_hub_finished hub2
rt_add_label hub2 hub2RedRT red
# Verify:
#   get_vhub_state hub2
#   get_rt_state hub2 hub2RedRT
#   get_rt hub2 hub2RedRT
# Reset:
#   reset_rt hub2 hub2RedRT
# Delete
#   delete_rt hub2 hub2RedRT
create_rt hub2 hub2BlueRT
rt_add_label hub2 hub2BlueRT blue
cx_set_rt hub2 spoke21 hub2RedRT hub2RedRT,defaultRouteTable,hub2CSRT
wait_until_hub_finished hub2
cx_set_rt hub2 spoke22 hub2RedRT hub2RedRT,defaultRouteTable,hub2CSRT
wait_until_hub_finished hub2
cx_set_rt hub2 spoke23 hub2BlueRT hub2BlueRT,defaultRouteTable,hub2CSRT
wait_until_hub_finished hub2
cx_set_rt hub2 spoke24 hub2CSRT hub2BlueRT,hub2RedRT,defaultRouteTable,hub2CSRT

# Optional: common services RT
create_rt hub1 hub1CSRT
rt_add_label hub1 hub1CSRT common
create_rt hub2 hub2CSRT
rt_add_label hub2 hub2CSRT common

# branches
wait_until_gw_finished hub1
vpncx_set_prop_rt hubvpn1 branch1 defaultRouteTable,hub1RedRT,hub1BlueRT,hub1CSRT
wait_until_gw_finished hub2
vpncx_set_prop_rt hubvpn2 branch2 defaultRouteTable,hub2RedRT,hub2BlueRT,hub2CSRT
wait_until_gw_finished hub2
vpncx_set_prop_rt hubvpn2 branch3 defaultRouteTable,hub2RedRT,hub2BlueRT,hub2CSRT
# Verify
#   get_vpngw_state

# Add static routes to short-circuit vnets (????)
# spoke1-to-spoke4
spoke1_cx_id=$(az network vhub connection show -n spoke1 --vhub-name hub1 -g $rg --query id -o tsv)
spoke4_cx_id=$(az network vhub connection show -n spoke4 --vhub-name hub2 -g $rg --query id -o tsv)
rt_add_route hub1 hub1RedRT $spoke4_prefix $spoke4_cx_id
rt_add_route hub2 hub1BlueRT $spoke1_prefix $spoke1_cx_id
# Verify:
#   get_vhub_state
#   get_rt_state hub1 hub1RedRT
#   get_rt_state hub2 hub1BlueRT
#   get_rt hub2 hub1RedRT
# Delete
#   rt_delete_routes hub1 hub1RedRT

# Optional: hub1 label config
wait_until_hub_finished hub1
cx_set_prop_labels hub1 spoke11 red,common,default
wait_until_hub_finished hub1
cx_set_prop_labels hub1 spoke12 red,common,default
wait_until_hub_finished hub1
cx_set_prop_labels hub1 spoke13 blue,common,default
wait_until_hub_finished hub1
cx_set_prop_labels hub1 spoke14 red,blue,common,default
wait_until_hub_finished hub2
cx_set_prop_labels hub2 spoke21 red,common,default
wait_until_hub_finished hub2
cx_set_prop_labels hub2 spoke22 red,common,default
wait_until_hub_finished hub2
cx_set_prop_labels hub2 spoke23 blue,common,default
wait_until_hub_finished hub2
cx_set_prop_labels hub2 spoke24 red,blue,common,default
wait_until_gw_finished hubvpn1
vpncx_set_prop_labels hubvpn1 branch1 red,blue,common,default
wait_until_gw_finished hubvpn2
vpncx_set_prop_labels hubvpn2 branch2 red,blue,common,default
wait_until_gw_finished hubvpn2
vpncx_set_prop_labels hubvpn2 branch3 red,blue,common,default

#################
# FW Mgr (RTv3) #
#################
azfw1_id=$(az network firewall show -n azfw1 -g $rg -o tsv --query id)
azfw2_id=$(az network firewall show -n azfw2 -g $rg -o tsv --query id)
rt_add_route hub1 defaultRouteTable 0.0.0.0/0 $azfw1_id
# Verify:
# get_rt_state hub1
# get_rt hub1 defaultRouteTable
# az network nic show-effective-route-table -n spoke1-vmVMNic -g $rg -o table
# Undo:
# rt_delete_routes hub1 defaultRouteTable
rt_add_route hub2 defaultRouteTable 0.0.0.0/0 $azfw2_id
# Verify:
# get_rt_state hub2
# get_rt hub2 defaultRouteTable
# az network nic show-effective-route-table -n spoke3-vmVMNic -g $rg -o table
# Undo:
# rt_delete_routes hub2 defaultRouteTable


###########
# zScaler #
###########

# Remove role assignment for zscaler SP
keyvault=erjositoKeyvault
appid=$(az keyvault secret show --vault-name $keyvault -n zscaler-app-id --query value -o tsv)
oid=$(az ad sp show --id $appid --query objectId -o tsv)
subid=$(az account show --query id -o tsv)
assignmentid=$(az role assignment list --scope "/subscriptions/${subid}" --assignee $oid --query '[0].id' -o tsv)
if [[ -z $assignmentid ]]
then
    echo "No assignment found for app ID $appid"
else
    az role assignment delete --ids $assignmentid -y
fi
# Add role assignment
appid=$(az keyvault secret show --vault-name erjositoKeyvault -n zscaler-app-id --query value -o tsv)
oid=$(az ad sp show --id $appid --query objectId -o tsv)
subid=$(az account show --query id -o tsv)
az role assignment create --scope "/subscriptions/${subid}" --assignee $oid --role Contributor

#################################
# Troubleshooting / Diagnostics #
#################################

az network public-ip list -g $rg -o table
az network nic list -g $rg -o table
az network nic show-effective-route-table -n spoke1-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke2-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke3-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke4-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke1-vmVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke2-vmVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke3-vmVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke4-vmVMNic -g $rg -o table
az network nic show-effective-route-table --ids $user_nva1_nic_id -o table
az network nic show-effective-route-table --ids $user_nva2_nic_id -o table
az network vhub connection list --vhub-name hub1 -g $rg -o table
az network vhub route-table list --vhub-name hub1 -g $rg -o table
az network vhub route list --vhub-name hub1 -g $rg -o table
az network vhub connection list --vhub-name hub2 -g $rg -o table
az network vhub route-table list --vhub-name hub2 -g $rg -o table
az network vhub route list --vhub-name hub2 -g $rg -o table
az network vpn-site list -g $rg -o table
az network vpn-gateway list -g $rg -o table
az network vpn-gateway connection list --gateway-name hubvpn1 -g $rg -o table
az network vpn-gateway connection list --gateway-name hubvpn2 -g $rg -o table
az network firewall policy list -g $rg -o table
az network firewall policy rule-collection-group list --policy myfwpolicy -g $rg -o table
az network firewall policy rule-collection-group collection list --policy myfwpolicy -g $rg --rule-collection-group-name ruleset01 -o table 
az network firewall policy rule-collection-group collection list --policy myfwpolicy -g $rg --rule-collection-group-name ruleset01   # There are no 'collection show' or 'collection rule list' commands
ssh -n -o BatchMode=yes $username@$branch1_ip "sh ip bgp"
ssh -n -o BatchMode=yes $username@$branch1_ip "sh ip interface brief"
ssh -n -o BatchMode=yes $username@$branch1_ip "sh ip route"

# Get hubs
az rest --method get --uri $vhubs_uri | jq '.value'
az rest --method get --uri $vhubs_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
# Get hub details
az rest --method get --uri $vhub1_uri
# Get hub ipconfig (not working)
az rest --method get --uri $vhub1_ipconfigs_uri
# Get hub vnet connections
az rest --method get --uri $vhub1_vnetcx_uri
az rest --method get --uri $vhub1_vnetcx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vhub1_vnetcx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
az rest --method get --uri $vhub2_vnetcx_uri
az rest --method get --uri $vhub2_vnetcx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vhub2_vnetcx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
# Get RTv2 (aka routeTable)
az rest --method get --uri $vhub1_rt_uri
# Get hub RTs (aka hubRouteTable)
az rest --method get --uri $vhub1_hubrt_uri
az rest --method get --uri $vhub1_hubrt_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vhub2_hubrt_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
# Get hub default hubRT
az rest --method get --uri $vhub1_default_hubrt_uri
az rest --method get --uri $vhub2_default_hubrt_uri
# Get hub BGP connections (NOT WORKING!!!)
az rest --method get --uri $vhub1_bgp_uri
# Get hub effective routes (NOT WORKING!!!)
az rest --method get --uri $vhub1_effrt_uri
# Get VPN GWs
az rest --method get --uri $vpngws_uri
az rest --method get --uri $vpngws_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
 # Get VPN GW details
az rest --method get --uri $vpngw1_uri
az rest --method get --uri $vpngw2_uri
# Get VPN GW connections
az rest --method get --uri $vpngw1_cx_uri
az rest --method get --uri $vpngw1_cx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vpngw1_cx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
az rest --method get --uri $vpngw2_cx_uri
az rest --method get --uri $vpngw2_cx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vpngw2_cx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
# Get VPN Sites
az rest --method get --uri $vpnsites_uri
az rest --method get --uri $vpnsites_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'

##########################
# Delete AzFW and vpnGWs #
##########################

az network vpn-gateway delete -n hubvpn1 -g $rg
az network vpn-gateway delete -n hubvpn2 -g $rg
az network firewall delete -n azfw1 -g $rg
az network firewall delete -n azfw2 -g $rg

#########################
# Log Analytics queries #
#########################

logws_customerid=$(az monitor log-analytics workspace show -n $logws_name -g $rg --query customerId -o tsv)
# Log summary
query='AzureDiagnostics 
| where TimeGenerated >= ago(15m) 
| summarize count() by ResourceType'
# AZFW log summary
query='AzureDiagnostics 
| where ResourceType == "AZUREFIREWALLS" 
//| summarize count() by Category
| summarize count() by bin(TimeGenerated, 1h), Category
| where TimeGenerated >= ago(6h)'
# AzFW app rule deny logs
query='AzureDiagnostics 
| where ResourceType == "AZUREFIREWALLS" 
| where Category == "AzureFirewallApplicationRule" 
| where TimeGenerated >= ago(5m) 
| project Protocol=split(msg_s, " ")[0], From=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",3,4)], To=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",5,6)], Action=trim_end(".", tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",7,8)])), Rule_Collection=iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="traffic.", "AzureInternalTraffic", iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="matched.","NoRuleMatched",trim_end(".",tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)])))), Rule=iif(split(msg_s, " ")[11]=="Proceeding" or split(msg_s, " ")[12]=="Proceeding","DefaultAction",split(msg_s, " ")[12]), msg_s 
| where Rule_Collection != "AzureInternalTraffic" 
//| where Action == "Deny" 
| where Action == "Allow" 
| take 5'
# AzFW net rule logs
query='AzureDiagnostics
| where Category == "AzureFirewallNetworkRule"
| where TimeGenerated >= ago(5m) 
| parse msg_s with Protocol " request from " SourceIP ":" SourcePortInt:int " to " TargetIP ":" TargetPortInt:int *
| parse msg_s with * ". Action: " Action1a
| parse msg_s with * " was " Action1b " to " NatDestination
| parse msg_s with Protocol2 " request from " SourceIP2 " to " TargetIP2 ". Action: " Action2
| extend SourcePort = tostring(SourcePortInt),TargetPort = tostring(TargetPortInt)
| extend Action = case(Action1a == "", case(Action1b == "",Action2,Action1b), Action1a),Protocol = case(Protocol == "", Protocol2, Protocol),SourceIP = case(SourceIP == "", SourceIP2, SourceIP),TargetIP = case(TargetIP == "", TargetIP2, TargetIP),SourcePort = case(SourcePort == "", "N/A", SourcePort),TargetPort = case(TargetPort == "", "N/A", TargetPort),NatDestination = case(NatDestination == "", "N/A", NatDestination)
//| where Action == "Deny" 
//| project TimeGenerated, msg_s, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // with msg_s
| project TimeGenerated, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // without msg_s
| where TargetPort == "22"
| take 20 '
# VPNGW log summary
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where TimeGenerated >= ago(5m) 
| summarize count() by Category'
# VPNGW IKE diagnostics
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "IKEDiagnosticLog" 
| where TimeGenerated >= ago(5m) 
| project Message
| take 10'
# VPNGW Route diagnostics (BGP connected/disconnected events)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "RouteDiagnosticLog" 
| where TimeGenerated >= ago(2h) 
| project TimeGenerated, Resource, peerAddress_s, OperationName, Message
| take 20'
# VPNGW Route diagnostics summary (the presence of logs indicate BGP adjacency instability)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "RouteDiagnosticLog" 
| where TimeGenerated >= ago(6h) 
| summarize count() by OperationName'
# VPNGW Tunnel diagnostics summary (the presence of logs indicate tunnel instability)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "TunnelDiagnosticLog" 
| where TimeGenerated >= ago(2h) 
| summarize count() by OperationName'
# VPNGW Tunnel diagnostics (the presence of logs indicate tunnel instability)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "TunnelDiagnosticLog" 
| where TimeGenerated >= ago(15m) 
| project TimeGenerated, Resource, remoteIP_s, stateChangeReason_s, status_s
| take 20'
# VPNGW Gateway log summary
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where TimeGenerated >= ago(10m) 
| summarize count() by Category'
# Search somehting
query='search "azfw"'
# Send query
az monitor log-analytics query -w $logws_customerid --analytics-query $query -o tsv
