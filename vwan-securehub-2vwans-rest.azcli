############################################################################
# Created by Jose Moreno
# August 2020
#
# Creates a VWAN environment using the 2020-05-01 APIs for custom routing
# It creates two distinct VWANs, and connects them via VPN
# Branches dual-connected to both VWANs
############################################################################

# Variables
rg=twovwans
vwan1_name=vwan1
vwan2_name=vwan2
location1=westeurope
location2=uksouth
username=jose
password=Microsoft123!
publisher=cisco
offer=cisco-csr-1000v
sku=16_12-byol
version=$(az vm image list -p $publisher -f $offer -s $sku --all --query '[0].version' -o tsv)
user_hub1_1st_octets=10.1.0
user_hub1_prefix=${user_hub1_1st_octets}.0/24
user_hub1_subnet=${user_hub1_1st_octets}.0/26
user_hub1_nva_ip=${user_hub1_1st_octets}.10
user_hub1_fw_subnet=${user_hub1_1st_octets}.128/26
user_hub2_1st_octets=10.2.0
user_hub2_prefix=${user_hub2_1st_octets}.0/24
user_hub2_subnet=${user_hub2_1st_octets}.0/26
user_hub2_nva_ip=${user_hub2_1st_octets}.10
user_hub2_fw_subnet=${user_hub2_1st_octets}.128/26
branch1_prefix=10.1.201.0/24
branch1_subnet=10.1.201.0/26
branch1_bgp_ip=10.1.201.10
branch2_prefix=10.2.202.0/24
branch2_subnet=10.2.202.0/26
branch2_bgp_ip=10.2.202.10
branch3_prefix=10.2.203.0/24
branch3_subnet=10.2.203.0/26
branch3_bgp_ip=10.2.203.10
vwan_hub1_prefix=192.168.1.0/24
vwan_hub2_prefix=192.168.2.0/24
vwan_hub1_asn=65515
vwan_hub2_asn=65515
branch1_asn=65501
branch2_asn=65502
branch3_asn=65503
nva_size=Standard_B2ms
vm_size=Standard_B1ms
logws_name=log$RANDOM

####################
#   JSON scripts   #
####################

# REST Variables
vwan_api_version=2020-05-01
subscription_id=$(az account show --query id -o tsv)
# JSON
vwan_json='{location: $location, properties: {disableVpnEncryption: false, type: $sku}}'
vhub_json='{location: $location, properties: {virtualWan: {id: $vwan_id}, addressPrefix: $hub_prefix, sku: $sku}}'
vpnsitelink_json='{name: $link_name, properties: {ipAddress: $remote_pip, bgpProperties: {bgpPeeringAddress: $remote_bgp_ip, asn: $remote_asn}, linkProperties: {linkProviderName: "vendor1", linkSpeedInMbps: 100}}}'
vpnsite_json='{location: $location, properties: {virtualWan: {id: $vwan_id}, addressSpace: { addressPrefixes: [ $site_prefix ] }, isSecuritySite: $security, vpnSiteLinks: [ '${vpnsitelink_json}']}}'
vpnsitelink_nobgp_json='{name: $link_name, properties: {ipAddress: $remote_pip, linkProperties: {linkProviderName: "vendor1", linkSpeedInMbps: 100}}}'
vpnsite_nobgp_json='{location: $location, properties: {virtualWan: {id: $vwan_id}, addressSpace: { addressPrefixes: [ $site_prefix ] }, isSecuritySite: $security, vpnSiteLinks: [ '${vpnsitelink_nobgp_json}']}}'
cx_json='{name: $cx_name, properties: {connectionBandwidth: 200, vpnConnectionProtocolType: "IKEv2", enableBgp: true, sharedKey: $psk, vpnSiteLink: {id: $site_link_id}}}'
vpncx_json='{properties: {enableInternetSecurity: true, remoteVpnSite: {id: $site_id}, vpnLinkConnections: ['$cx_json']}}'
cx_nobgp_json='{name: $cx_name, properties: {connectionBandwidth: 200, vpnConnectionProtocolType: "IKEv2", enableBgp: false, sharedKey: $psk, vpnSiteLink: {id: $site_link_id}}}'
vpncx_nobgp_json='{properties: {enableInternetSecurity: true, remoteVpnSite: {id: $site_id}, vpnLinkConnections: ['$cx_nobgp_json']}}'
vpngw_json='{location: $location, properties: {virtualHub: {id: $vhub_id}, connections: [], bgpSettings: {asn: $asn, peerWeight: 0}}}'
vnet_cx_json='{properties: {remoteVirtualNetwork: {id: $vnet_id}, enableInternetSecurity: true}}'
rt_json='{properties: {routes: [], labels: []}}'
route_json='{name: $name, destinationType: "CIDR", destinations: [ $prefixes ], nextHopType: $type, nextHop: $nexthop }'
cxroute_json='{name: $name, addressPrefixes: [ $prefixes ], nextHopIpAddress: $nexthop }'
# REST URIs
vwan_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualWans/$vwan?api-version=$vwan_api_version"
vhubs_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs?api-version=$vwan_api_version"
vhub1_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub1"
vhub2_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub2"
vhub3_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub3"
vhub1_uri="${vhub1_base_uri}?api-version=$vwan_api_version"
vhub1_ipconfigs_uri="${vhub1_base_uri}/ipConfigurations?api-version=$vwan_api_version"
vhub1_bgp_uri="${vhub1_base_uri}/bgpConnections?api-version=$vwan_api_version"
vhub1_vnetcx_uri="${vhub1_base_uri}/hubVirtualNetworkConnections?api-version=$vwan_api_version"
vhub1_vnetcx1_uri="${vhub1_base_uri}/hubVirtualNetworkConnections/spoke1?api-version=$vwan_api_version"
vhub1_vnetcx2_uri="${vhub1_base_uri}/hubVirtualNetworkConnections/spoke2?api-version=$vwan_api_version"
vhub1_vnetcxhub1_uri="${vhub1_base_uri}/hubVirtualNetworkConnections/userhub1?api-version=$vwan_api_version"
vhub1_rt_uri="${vhub1_base_uri}/routeTables?api-version=$vwan_api_version"
vhub1_hubrt_uri="${vhub1_base_uri}/hubRouteTables?api-version=$vwan_api_version"
vhub1_effrt_uri="${vhub1_base_uri}/effectiveRoutes?api-version=$vwan_api_version"
vhub1_default_hubrt_uri="${vhub1_base_uri}/hubRouteTables/defaultRouteTable?api-version=$vwan_api_version"
vhub2_uri="${vhub2_base_uri}?api-version=$vwan_api_version"
vhub2_rt_uri="${vhub2_base_uri}/routeTables?api-version=$vwan_api_version"
vhub2_hubrt_uri="${vhub2_base_uri}/hubRouteTables?api-version=$vwan_api_version"
vhub2_default_hubrt_uri="${vhub2_base_uri}/hubRouteTables/defaultRouteTable?api-version=$vwan_api_version"
vhub2_vnetcx_uri="${vhub2_base_uri}/hubVirtualNetworkConnections?api-version=$vwan_api_version"
vhub2_vnetcx3_uri="${vhub2_base_uri}/hubVirtualNetworkConnections/spoke3?api-version=$vwan_api_version"
vhub2_vnetcx4_uri="${vhub2_base_uri}/hubVirtualNetworkConnections/spoke4?api-version=$vwan_api_version"
vhub2_vnetcxhub2_uri="${vhub2_base_uri}/hubVirtualNetworkConnections/userhub2?api-version=$vwan_api_version"
vpnsites_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites?api-version=$vwan_api_version"
vpnsite1_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/branch1?api-version=$vwan_api_version"
vpnsite2_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/branch2?api-version=$vwan_api_version"
vpnsite3_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/branch3?api-version=$vwan_api_version"
vpngws_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways?api-version=$vwan_api_version"
vpngw1_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn1"
vpngw1_uri="${vpngw1_base_uri}?api-version=$vwan_api_version"
vpngw1_cx_uri="${vpngw1_base_uri}/vpnConnections?api-version=$vwan_api_version"
vpngw1_cx1_uri="${vpngw1_base_uri}/vpnConnections/branch1?api-version=$vwan_api_version"
vpngw2_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn2"
vpngw2_uri="${vpngw2_base_uri}?api-version=$vwan_api_version"
vpngw2_cx_uri="${vpngw2_base_uri}/vpnConnections?api-version=$vwan_api_version"
vpngw2_cx2_uri="${vpngw2_base_uri}/vpnConnections/branch2?api-version=$vwan_api_version"
vpngw2_cx3_uri="${vpngw2_base_uri}/vpnConnections/branch3?api-version=$vwan_api_version"
vpngw3_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn3"

####################
# Helper functions #
####################

wait_interval=5
function wait_until_finished {
     resource_id=$1
     resource_name=$(echo $resource_id | cut -d/ -f 9)
     echo "Waiting for resource $resource_name to finish provisioning..."
     start_time=`date +%s`
     state=$(az resource show --id $resource_id --query properties.provisioningState -o tsv)
     until [[ "$state" == "Succeeded" ]] || [[ "$state" == "Failed" ]] || [[ -z "$state" ]]
     do
        sleep $wait_interval
        state=$(az resource show --id $resource_id --query properties.provisioningState -o tsv)
     done
     if [[ -z "$state" ]]
     then
        echo "Something really bad happened..."
     else
        run_time=$(expr `date +%s` - $start_time)
        ((minutes=${run_time}/60))
        ((seconds=${run_time}%60))
        echo "Resource $resource_name provisioning state is $state, wait time $minutes minutes and $seconds seconds"
     fi
}

function wait_until_hub_finished {
    hub_name=$1
    hub_id=$(az network vhub show -n $hub_name -g $rg --query id -o tsv)
    wait_until_finished $hub_id
    echo "Hub state is $(get_vhub_state $hub_name), checking connections..."
    connections=$(get_vnetcx_state $hub_name | grep Updating)
    until [[ -z "$connections" ]]
    do
        sleep $wait_interval
        connections=$(get_vnetcx_state $hub_name | grep Updating)
    done
    echo "No connections in Updating state in hub $hub_name, checking route tables..."
    rts=$(get_rt_state $hub_name | grep Updating)
    until [[ -z "$rts" ]]
    do
        sleep $wait_interval
        rts=$(get_rt_state $hub_name | grep Updating)
    done
}

function wait_until_gw_finished {
    gw_name=$1
    gw_id=$(az network vpn-gateway show -n $gw_name -g $rg --query id -o tsv)
    wait_until_finished $gw_id
}

# Get JSON for a hub or all hubs
function get_vhub {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}?api-version=$vwan_api_version"
    if [[ -z "${hub_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a hub or all hubs
function get_vhub_state {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}?api-version=$vwan_api_version"
    if [[ -z "${hub_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

function list_vhub {
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name'
}


# Get JSON for a vnet connection or all vnet connections in a hub
function get_vnetcx {
    hub_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a vnet cx in a hub or all vnet cx in a hub
function get_vnetcx_state {
    hub_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

# List vnet connections
function list_vnetcx {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name' 2>/dev/null
}

# Get JSON for a hubRT or all hubRTs
function get_rt {
    hub_name=$1
    rt_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    if [[ -z "${rt_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a hubRT or all hubRTs
function get_rt_state {
    hub_name=$1
    rt_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    if [[ -z "${rt_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

# Get provisioningState for a hubRT or all hubRTs
function list_rt {
    hub_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name'
}

# Get JSON for a vpngw or all vpngw
function get_vpngw {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${gw_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a VPN GW or all VPN GWs
function get_vpngw_state {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${gw_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

function list_vpngw {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways?api-version=$vwan_api_version"
    az rest --method get --uri $uri | jq -r '.value[].name'
}

# Get BGP info for a VPN GW or all VPN GWs
function get_vpngw_bgp {
    gw_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${gw_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.bgpSettings})'
    else
        az rest --method get --uri $uri | jq -r '.properties.bgpSettings'
    fi
}

# Get VPN connections
function get_vpngw_cx {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.properties.connections'
    else
        az rest --method get --uri $uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'")'
    fi
}

# Get VPN connections state
function get_vpngw_cx_state {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [[ -z "${cx_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.properties.connections | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'") | .properties.provisioningState'
    fi
}

# Get JSON for a VPN site or all VPN sites
function get_vpnsite {
    site_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    if [[ -z "${site_name}" ]]
    then
        az rest --method get --uri $uri | jq '.value'
    else
        az rest --method get --uri $uri | jq
    fi
}

# Get provisioningState for a VPN site or all VPN sites
function get_vpnsite_state {
    site_name=$1
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    if [[ -z "${site_name}" ]]
    then
        az rest --method get --uri $uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
    else
        az rest --method get --uri $uri | jq -r '.properties.provisioningState'
    fi
}

#################
#       RT      #
#################

# Create Route Table (aka hubRouteTable)
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate
function create_rt {
    hub_name=$1
    rt_name=$2
    rt_label=$3
    rt_json_string=$(jq -n \
            $rt_json)
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    if [[ -n "$rt_label" ]]
    then
        rt_json_string=$(echo $rt_json_string | jq '.properties.labels += [ "'$rt_label'" ] | {name, properties}')
    fi
    wait_until_hub_finished $hub_name
    az rest --method put --uri $rt_uri --body $rt_json_string   # PUT
    # az rest --method get --uri $rt_uri                        # GET
    # az rest --method delete --uri $rt_uri                     # DELETE
}

# Delete rt
function delete_rt {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    az rest --method delete --uri $rt_uri
}

# Update vnet connection associated RT
function cx_set_ass_rt {
    hub_name=$1
    cx_name=$2
    new_rt_name=$3
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_rt_id="/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_rt_name}"
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.associatedRouteTable.id = "'$new_rt_id'" | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $cx_uri --body $cx_json_updated
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.associatedRouteTable.id'
}

# Update vnet connection propagated RT
# Example: cx_set_prop_rt hub1 spoke1 redRT,defaultRouteTable
function cx_set_prop_rt {
    hub_name=$1
    cx_name=$2
    IFS=',' read -r -a new_rt_names <<< "$3"
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_rt_ids=""
    for new_rt_name in ${new_rt_names[@]}; do
        new_rt_ids="${new_rt_ids}{\"id\": \"/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_rt_name}\"},"
    done
    new_rt_ids="${new_rt_ids: : -1}"   # Remove trailing comma
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.propagatedRouteTables.ids = ['$new_rt_ids'] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $cx_uri --body $cx_json_updated
}

# Modify propagation labels
function cx_set_prop_labels {
    hub_name=$1
    cx_name=$2
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_labels <<< "$3"
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_labels_txt=""
    for new_label in ${new_labels[@]}; do
        new_labels_txt="${new_labels_txt}\"${new_label}\","
    done
    new_labels_txt="${new_labels_txt: : -1}"   # Remove trailing comma
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.propagatedRouteTables.labels = ['${new_labels_txt}'] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $cx_uri --body $cx_json_updated
}

# Modify propagated RT for VPN connection
function vpncx_set_prop_rt {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_rt_names <<< "$3"
    hub_id=$(az network vpn-gateway show -n $gw_name -g $rg --query 'virtualHub.id' -o tsv)
    hub_name=$(echo $hub_id | cut -d/ -f 9)
    new_rt_ids=""
    for new_rt_name in ${new_rt_names[@]}
    do
        new_rt_ids="${new_rt_ids}{\"id\": \"/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_rt_name}\"},"
    done
    new_rt_ids="${new_rt_ids: : -1}"   # Remove trailing comma
    vpn_json=$(az rest --method get --uri $uri)
    connections=$(echo $vpn_json | jq '.properties.connections | map({name, properties})')
    # Remove unneeded attributes
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].resourceGroup)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].etag)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].type)')
    connections_updated=$(echo $connections | jq 'map(if .name=="'$cx_name'" then .properties.routingConfiguration.propagatedRouteTables.ids=['"$new_rt_ids"'] else . end)')
    # Optionally, set labels
    if [[ -n "$4" ]]
    then
        IFS=',' read -r"$arr_opt" new_labels <<< "$4"
        new_labels_txt=""
        for new_label in ${new_labels[@]}; do
            new_labels_txt="${new_labels_txt}\"${new_label}\","
        done
        new_labels_txt="${new_labels_txt: : -1}"   # Remove trailing comma
        connections_updated=$(echo $connections_updated | jq 'map(if .name=="'$cx_name'" then .properties.routingConfiguration.propagatedRouteTables.labels=['"$new_labels_txt"'] else . end)')
    fi
    # Send JSON
    vpn_json_updated=$(echo $vpn_json | jq '.properties.connections = '${connections_updated}' | {name, properties, location}')
    wait_until_gw_finished $gw_name
    az rest --method put --uri $uri --body $vpn_json_updated
}

function vpncx_set_prop_labels {
    gw_name=$1
    cx_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_labels <<< "$3"
    hub_id=$(az network vpn-gateway show -n $gw_name -g $rg --query 'virtualHub.id' -o tsv)
    hub_name=$(echo $hub_id | cut -d/ -f 9)
    new_labels_txt=""
    for new_label in ${new_labels[@]}; do
        new_labels_txt="${new_labels_txt}\"${new_label}\","
    done
    new_labels_txt="${new_labels_txt: : -1}"   # Remove trailing comma
    vpn_json=$(az rest --method get --uri $uri)
    connections=$(echo $vpn_json | jq '.properties.connections | map({name, properties})')
    # Remove unneeded attributes
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].resourceGroup)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].etag)')
    connections=$(echo $connections | jq 'del(.[].properties.vpnLinkConnections[].type)')
    connections_updated=$(echo $connections | jq 'map(if .name=="'$cx_name'" then .properties.routingConfiguration.propagatedRouteTables.labels=['"$new_labels_txt"'] else . end)')
    vpn_json_updated=$(echo $vpn_json | jq '.properties.connections = '${connections_updated}' | {name, properties, location}')
    wait_until_gw_finished $gw_name
    az rest --method put --uri $uri --body $vpn_json_updated
}

# Update vnet connection associated and propagated RT at the same time
# example: cx_set_rt hub1 spoke1 redRT redRT,defaultRouteTable
function cx_set_rt {
    hub_name=$1
    cx_name=$2
    new_assrt_name=$3
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    IFS=',' read -r"$arr_opt" new_proprt_names <<< "$4"
    echo "Setting associated route table to $new_assrt_name, propagated route tables to $new_proprt_names"  # DEBUG
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    new_assrt_id="/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_assrt_name}"
    new_proprt_ids=""
    for new_proprt_name in ${new_proprt_names[@]}; do
        new_proprt_ids="${new_proprt_ids}{\"id\": \"/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${new_proprt_name}\"},"
    done
    new_proprt_ids="${new_proprt_ids: : -1}"   # Remove trailing comma
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.associatedRouteTable.id = "'$new_assrt_id'" | .properties.routingConfiguration.propagatedRouteTables.ids = ['$new_proprt_ids'] | {name, properties}')
    if [[ -n "$5" ]]
    then
        IFS=',' read -r"$arr_opt" new_labels <<< "$5"
        new_labels_txt=""
        for new_label in ${new_labels[@]}; do
            new_labels_txt="${new_labels_txt}\"${new_label}\","
        done
        new_labels_txt="${new_labels_txt: : -1}"   # Remove trailing comma
        cx_json_updated=$(echo $cx_json_updated | jq '.properties.routingConfiguration.propagatedRouteTables.labels = ['${new_labels_txt}'] | {name, properties}')
    fi
    wait_until_hub_finished $hub_name
    az rest --method put --uri $cx_uri --body $cx_json_updated
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.associatedRouteTable.id'
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.propagatedRouteTables.ids'
    # az rest --method get --uri $cx_uri | jq '.properties.provisioningState'
}

# Add routes to RT
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate#hubroute
function rt_add_route {
    hub_name=$1
    rt_name=$2
    prefix=$3
    nexthop=$4
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    # type (next hop): CIDR, resourceId, Service
    # prefixes: comma-separated prefix list
    new_route_json_string=$(jq -n \
            --arg name "route$RANDOM" \
            --arg type "ResourceId" \
            --arg prefixes "$prefix" \
            --arg nexthop "$nexthop" \
            $route_json)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.routes += [ '$new_route_json_string' ] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
    # az rest --method get --uri $rt_uri | jq '.properties.routes'  # GET
}

# Delete all routes from RT
function rt_delete_routes {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.routes = [] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
    # az rest --method get --uri $rt_uri | jq '.properties.routes'  # GET
}

# Add routes to vnet conection
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubvirtualnetworkconnections/createorupdate#staticroute
# Example: cx_add_routes hub1 spoke1 192.168.0.0/16 172.21.10.68
function cx_add_routes {
    hub_name=$1
    cx_name=$2
    prefix=$3
    nexthop=$4
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    # prefixes: comma-separated prefix list
    new_route_json_string=$(jq -n \
            --arg name "route$RANDOM" \
            --arg prefixes "$prefix" \
            --arg nexthop "$nexthop" \
            $cxroute_json)
    existing_routes=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes[]')
    if [ -z "${existing_routes}" ]
    then
        new_routes=${new_route_json_string}
    else
        new_routes=${existing_routes},${new_route_json_string}
    fi
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes = ['$new_routes'] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $cx_uri --body $cx_json_updated  # PUT
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes'  # GET
}

# Delete all routes from vnet cx
function cx_delete_routes {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes = [] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $cx_uri --body $cx_json_updated    # PUT
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.vnetRoutes.staticRoutes'  # GET
}

# Delete all labels from vnet cx
function cx_delete_labels {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json=$(az rest --method get --uri $cx_uri)
    cx_json_updated=$(echo $cx_json | jq '.properties.routingConfiguration.propagatedRouteTables.labels = [] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $cx_uri --body $cx_json_updated    # PUT
    # az rest --method get --uri $cx_uri | jq '.properties.routingConfiguration.propagatedRouteTables.labels'  # GET
}

# Add label to route table
# https://docs.microsoft.com/en-us/rest/api/virtualwan/hubroutetables/createorupdate#hubroute
function rt_add_label {
    hub_name=$1
    rt_name=$2
    new_label=$3
    wait_until_hub_finished $hub_name
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.labels += [ "'$new_label'" ] | {name, properties}')
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
}

# Delete all labels
function rt_delete_labels {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '.properties.labels = [] | {name, properties}')
    wait_until_hub_finished $hub_name
    az rest --method put --uri $rt_uri --body $rt_json_updated    # PUT
}


#################
#  Reset stuff  #
#################

# reset vhub
function reset_vhub {
    hub_name=$1
    hub_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}?api-version=$vwan_api_version"
    hub_json_current=$(az rest --method get --uri $hub_uri)
    hub_json_updated=$(echo $hub_json_current | jq '{name, location, properties}')
    az rest --method put --uri $hub_uri --body $hub_json_updated
}

# reset vhub
function reset_rt {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    rt_json_current=$(az rest --method get --uri $rt_uri)
    rt_json_updated=$(echo $rt_json_current | jq '{name, location, properties}')
    az rest --method put --uri $rt_uri --body $rt_json_updated
}

# reset vnet cx
function reset_vhub_cx {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    cx_json_current=$(az rest --method get --uri $cx_uri)       # GET
    cx_json_updated=$(echo $cx_json_current | jq '{name, location, properties}')
    # az rest --method delete --uri $cx_uri                     # DELETE
    # Here you should wait until the delete operation finishes!!!!
    az rest --method put --uri $cx_uri --body $cx_json_updated  # PUT
}

# reset vpngw - NOT WORKING!
function reset_vpngw {
    gw_name=$1
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    gw_json_current=$(az rest --method get --uri $gw_uri)
    gw_json_updated=$(echo $gw_json_current | jq '{name, location, properties}')
    az rest --method put --uri $gw_uri --body $gw_json_updated
}


##################
#  Summary info  #
##################

# Get label info
function get_cx_labels {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    az rest --method get --uri $cx_uri | jq -r '.properties.routingConfiguration.propagatedRouteTables.labels[]' | paste -sd, - 2>/dev/null
}
function get_rt_labels {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    az rest --method get --uri $rt_uri | jq -r '.properties.labels[]' | paste -sd, - 2>/dev/null
}
function get_rt_routes {
    hub_name=$1
    rt_name=$2
    rt_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    az rest --method get --uri $rt_uri | jq -r '.properties.routes[] | .destinations[],.nextHop' | paste -sd, - 2>/dev/null
}
function get_vpncx_labels {
    gw_name=$1
    cx_name=$2
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    az rest --method get --uri $gw_uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'") | .properties.routingConfiguration.propagatedRouteTables.labels[]' | paste -sd, - 2>/dev/null
}
function list_vpncx {
    gw_name=$1
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    az rest --method get --uri $gw_uri | jq -r '.properties.connections[].name' 2>/dev/null
}

function labels {
    # Vnet connections
    hubs=$(list_vhub)
    while IFS= read -r hub_name; do
        vnet_cxs=$(list_vnetcx $hub_name)
        if [[ -n "$vnet_cxs" ]]
        then
            while IFS= read -r vnetcx_name; do
                echo "${hub_name}/${vnetcx_name} connection:  $(get_cx_labels $hub_name $vnetcx_name)"
            done <<< "$vnet_cxs"
        else
            echo "No vnet connections in hub $hub_name"
        fi
    done <<< "$hubs"
    # VPN connections
    vpngws=$(list_vpngw)
    while IFS= read -r gw_name; do
        vpn_cxs=$(list_vpncx $gw_name)
        if [[ -n "$vpn_cxs" ]]
        then
            while IFS= read -r vpncx_name; do
                echo "${gw_name}/${vpncx_name} connection:  $(get_vpncx_labels $gw_name $vpncx_name)"
            done <<< "$vpn_cxs"
        else
            echo "No VPN connections in gateway $gw_name"
        fi
    done <<< "$vpngws"
    # Route Tables
    while IFS= read -r hub_name; do
        rts=$(list_rt $hub_name)
        if [[ -n "$rts" ]]
        then
            while IFS= read -r rt_name; do
                echo "${hub_name}/${rt_name}:  $(get_rt_labels $hub_name $rt_name)"
            done <<< "$rts"
        else
            echo "No route tables in hub $hub_name"
        fi
    done <<< "$hubs"
}

function state {
    # Hubs
    hubs=$(list_vhub)
    while IFS= read -r hub_name; do
        echo "${hub_name}: $(get_vhub_state $hub_name)"
        # Vnet connections
        vnet_cxs=$(list_vnetcx $hub_name)
        if [[ -n "$vnet_cxs" ]]
        then
            while IFS= read -r vnetcx_name; do
                echo "${hub_name}/${vnetcx_name} connection:  $(get_vnetcx_state $hub_name $vnetcx_name)"
            done <<< "$vnet_cxs"
        else
            echo "No vnet connections in hub $hub_name"
        fi
        # Route Tables
        rts=$(list_rt $hub_name)
        if [[ -n "$rts" ]]
        then
            while IFS= read -r rt_name; do
                echo "${hub_name}/${rt_name}:  $(get_rt_state $hub_name $rt_name)"
            done <<< "$rts"
        else
            echo "No route tables in hub $hub_name"
        fi
    done <<< "$hubs"
    # VPN connections
    vpngws=$(list_vpngw)
    while IFS= read -r gw_name; do
        echo "${gw_name}: $(get_vpngw_state $gw_name)"
        vpn_cxs=$(list_vpncx $gw_name)
        if [[ -n "$vpn_cxs" ]]
        then
            while IFS= read -r vpncx_name; do
                echo "${gw_name}/${vpncx_name} connection:  $(get_vpngw_cx_state $gw_name $vpncx_name)"
            done <<< "$vpn_cxs"
        else
            echo "No VPN connections in gateway $gw_name"
        fi
    done <<< "$vpngws"
}

# Get associated/propagated routing tables
function print_routing {
    routing=$1
    assrt=$(echo $routing | jq -r '.associatedRouteTable.id')
    assrt_hub=$(echo $assrt | cut -d/ -f 9)
    assrt_name=$(echo $assrt | cut -d/ -f 11)
    proprt=$(echo $routing | jq -r '.propagatedRouteTables.ids[].id')
    proprt_txt=""
    while IFS= read -r proprt_id; do
        proprt_hub=$(echo $proprt_id | cut -d/ -f 9)
        proprt_name=$(echo $proprt_id | cut -d/ -f 11)
        if [[ -n "$proprt_txt" ]]
        then
            proprt_txt+=", "
        fi
        proprt_txt+=${proprt_hub}/${proprt_name}
    done <<< "$proprt"
    proplbls=$(echo $routing | jq -r '.propagatedRouteTables.labels[]')
    proplbl_txt=""
    while IFS= read -r label; do
        if [[ -n "$proplbl_txt" ]]
        then
            proplbl_txt+=", "
        fi
        proplbl_txt+=${label}
    done <<< "$proplbls"
    echo "  * Associated: ${assrt_hub}/${assrt_name}"
    echo "  * Propagated: $proprt_txt - Labels: ${proplbl_txt}"
}
function get_cx_routing {
    hub_name=$1
    cx_name=$2
    cx_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubVirtualNetworkConnections/${cx_name}?api-version=$vwan_api_version"
    routing=$(az rest --method get --uri $cx_uri | jq -r '.properties.routingConfiguration')
    echo "$hub_name / $cx_name"
    print_routing $routing
}
function get_vpncx_routing {
    gw_name=$1
    cx_name=$2
    gw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/${gw_name}?api-version=$vwan_api_version"
    routing=$(az rest --method get --uri $gw_uri | jq -r '.properties.connections[] | select (.name == "'$cx_name'") | .properties.routingConfiguration')
    echo "$gw_name / $cx_name"
    print_routing $routing
}

function routing {
    # Vnet connections
    hubs=$(list_vhub)
    while IFS= read -r hub_name; do
        vnet_cxs=$(list_vnetcx $hub_name)
        if [[ -n "$vnet_cxs" ]]
        then
            while IFS= read -r vnetcx_name; do
                get_cx_routing $hub_name $vnetcx_name
            done <<< "$vnet_cxs"
        else
            echo "No vnet connections in hub $hub_name"
        fi
    done <<< "$hubs"
    # VPN connections
    vpngws=$(list_vpngw)
    while IFS= read -r gw_name; do
        vpn_cxs=$(list_vpncx $gw_name)
        if [[ -n "$vpn_cxs" ]]
        then
            while IFS= read -r vpncx_name; do
                get_vpncx_routing $gw_name $vpncx_name
            done <<< "$vpn_cxs"
        else
            echo "No VPN connections in gateway $gw_name"
        fi
    done <<< "$vpngws"
    # Route tables
    get_static
}

function get_rt_static {
    hub_name=$1
    rt_name=$2
    uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/${hub_name}/hubRouteTables/${rt_name}?api-version=$vwan_api_version"
    routes=$(az rest --method get --uri $uri | jq '.properties.routes')
    srch="/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/"
    routes=$(echo $routes | awk -v srch="$srch" '{sub(srch,"",$0); print$0}')
    srch="hubVirtualNetworkConnections/"
    routes=$(echo $routes | awk -v srch="$srch" '{sub(srch,"",$0); print$0}')
    srch="/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/azureFirewalls/"
    routes=$(echo $routes | awk -v srch="$srch" '{sub(srch,"",$0); print$0}')
    routes=$(echo $routes | jq -r '.[] | "  * \(.name)\t\(.destinations[])\t\(.nextHop)"')
    if [[ -n $routes ]]
    then
        echo $routes
    else
        echo "  * No static routes"
    fi
}

function get_static {
    # Hubs
    hubs=$(list_vhub)
    while IFS= read -r hub_name; do
        # Route Tables
        rts=$(list_rt $hub_name)
        if [[ -n "$rts" ]]
        then
            while IFS= read -r rt_name; do
                echo "${hub_name}/${rt_name} (labels: $(get_rt_labels $hub_name $rt_name))"
                get_rt_static $hub_name $rt_name
            done <<< "$rts"
        else
            echo "No route tables in hub $hub_name"
        fi
    done <<< "$hubs"
}


################
# Getting logs #
################

function init_log_vars {
    logws_created=$(az monitor log-analytics workspace list -g $rg --query '[0].name' -o tsv)
    if [[ -z $logws_created ]]
    then
        echo "Creating LA workspace..."
        az monitor log-analytics workspace create -n $logws_name -g $rg
    else
        logws_name=$(az monitor log-analytics workspace list -g $rg --query '[0].name' -o tsv)  # In case the log analytics workspace already exists
    fi
    logws_id=$(az resource list -g $rg -n $logws_name --query '[].id' -o tsv)
    logws_customerid=$(az monitor log-analytics workspace show -n $logws_name -g $rg --query customerId -o tsv)
}

function get_fw_logs_net {
    query='AzureDiagnostics
    | where Category == "AzureFirewallNetworkRule"
    | where TimeGenerated >= ago(5m) 
    | parse msg_s with Protocol " request from " SourceIP ":" SourcePortInt:int " to " TargetIP ":" TargetPortInt:int *
    | parse msg_s with * ". Action: " Action1a
    | parse msg_s with * " was " Action1b " to " NatDestination
    | parse msg_s with Protocol2 " request from " SourceIP2 " to " TargetIP2 ". Action: " Action2
    | extend SourcePort = tostring(SourcePortInt),TargetPort = tostring(TargetPortInt)
    | extend Action = case(Action1a == "", case(Action1b == "",Action2,Action1b), Action1a),Protocol = case(Protocol == "", Protocol2, Protocol),SourceIP = case(SourceIP == "", SourceIP2, SourceIP),TargetIP = case(TargetIP == "", TargetIP2, TargetIP),SourcePort = case(SourcePort == "", "N/A", SourcePort),TargetPort = case(TargetPort == "", "N/A", TargetPort),NatDestination = case(NatDestination == "", "N/A", NatDestination)
    //| where Action == "Deny" 
    //| project TimeGenerated, msg_s, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // with msg_s
    | project TimeGenerated, Resource, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // without msg_s
    | take 20 '
    az monitor log-analytics query -w $logws_customerid --analytics-query $query -o tsv
}

function get_fw_logs_app {
    query='AzureDiagnostics 
    | where ResourceType == "AZUREFIREWALLS" 
    | where Category == "AzureFirewallApplicationRule" 
    | where TimeGenerated >= ago(5m) 
    | project Protocol=split(msg_s, " ")[0], From=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",3,4)], To=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",5,6)], Action=trim_end(".", tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",7,8)])), Rule_Collection=iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="traffic.", "AzureInternalTraffic", iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="matched.","NoRuleMatched",trim_end(".",tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)])))), Rule=iif(split(msg_s, " ")[11]=="Proceeding" or split(msg_s, " ")[12]=="Proceeding","DefaultAction",split(msg_s, " ")[12]), msg_s 
    | where Rule_Collection != "AzureInternalTraffic" 
    //| where Action == "Deny" 
    | take 20'
    az monitor log-analytics query -w $logws_customerid --analytics-query $query -o tsv
}

##################
# VM Maintenance #
##################
function stop_vms {
    vms=$(az vm list -g $rg --query '[].name' -o tsv)
    while IFS= read -r vm_name; do
        echo "Stopping ${vm_name}..."
        az vm deallocate -n $vm_name -g $rg --no-wait
    done <<< "$vms"
    az vm list -d -g $rg -o table
}
function start_vms {
    vms=$(az vm list -g $rg --query '[].name' -o tsv)
    while IFS= read -r vm_name; do
        echo "Starting ${vm_name}..."
        az vm start -n $vm_name -g $rg --no-wait
    done <<< "$vms"
    az vm list -d -g $rg -o table
}

function add_to_hosts {
    ip=$1
    if [[ -n "$ip" ]]
    then
        ssh-keyscan -H $ip >> ~/.ssh/known_hosts
    fi
}

function get_ips {
    echo "Getting public IP addresses..."
    spoke11_jump_pip=$(az network public-ip show -n spoke11-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke11_jump_pip
    add_to_hosts $spoke11_jump_pip
    spoke12_jump_pip=$(az network public-ip show -n spoke12-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke12_jump_pip
    add_to_hosts $spoke12_jump_pip
    spoke13_jump_pip=$(az network public-ip show -n spoke13-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke13_jump_pip
    add_to_hosts $spoke13_jump_pip
    spoke14_jump_pip=$(az network public-ip show -n spoke14-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke14_jump_pip
    add_to_hosts $spoke14_jump_pip
    spoke15_jump_pip=$(az network public-ip show -n spoke15-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke15_jump_pip
    add_to_hosts $spoke15_jump_pip
    spoke21_jump_pip=$(az network public-ip show -n spoke21-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke21_jump_pip
    add_to_hosts $spoke21_jump_pip
    spoke22_jump_pip=$(az network public-ip show -n spoke22-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke22_jump_pip
    add_to_hosts $spoke22_jump_pip
    spoke23_jump_pip=$(az network public-ip show -n spoke23-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke23_jump_pip
    add_to_hosts $spoke23_jump_pip
    spoke24_jump_pip=$(az network public-ip show -n spoke24-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke24_jump_pip
    add_to_hosts $spoke24_jump_pip
    spoke25_jump_pip=$(az network public-ip show -n spoke25-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $spoke25_jump_pip
    add_to_hosts $spoke25_jump_pip
    branch1_ip=$(az network public-ip show -n branch1-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $branch1_ip
    add_to_hosts $branch1_ip
    branch2_ip=$(az network public-ip show -n branch2-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $branch2_ip
    add_to_hosts $branch2_ip
    branch3_ip=$(az network public-ip show -n branch3-pip -g $rg --query ipAddress -o tsv 2>/dev/null) && echo $branch3_ip
    add_to_hosts $branch3_ip
}

################
# VPN gateways #
################

function get_location {
    hub_id=$1
    case $hub_id in
    1)
        echo $location1
        ;;
    2)
        echo $location2
        ;;
    esac
}

function get_vwan_name {
    hub_id=$1
    case $hub_id in
    1)
        echo $vwan1_name
        ;;
    2)
        echo $vwan2_name
        ;;
    esac
}


function create_vpngw {
    hub_id=$1
    hub_name=hub${hub_id}
    vpngw_name=hubvpn${hub_id}
    location=$(get_location $hub_id)
    vpngw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/$vpngw_name?api-version=$vwan_api_version"
    vhub_id=$(az network vhub show -n $hub_name -g $rg --query id -o tsv)
    wait_until_finished $vhub_id
    vpngw_json_string=$(jq -n \
            --arg location "$location" \
            --arg vhub_id $vhub_id \
            --arg asn "65515" \
            $vpngw_json)
    az rest --method put --uri $vpngw_uri --body $vpngw_json_string  # PUT
}
function delete_vpngw {
    hub_id=$1
    vpngw_name=hubvpn${hub_id}
    vpngw_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/$vpngw_name?api-version=$vwan_api_version"
    az rest --method delete --uri $vpngw_uri                        # DELETE
}

# Connects site to VPNgw
function connect_branch {
    hub_id=$1
    branch_id=$2
    site_id=$(az network vpn-site show -n branch${hub_id}${branch_id} -g $rg --query id -o tsv)
    vpnsite_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/branch${hub_id}${branch_id}?api-version=$vwan_api_version"
    site_link_id=$(az rest --method get --uri $vpnsite_uri | jq -r '.properties.vpnSiteLinks[0].id')
    vpngw_id=$(az network vpn-gateway show -n hubvpn${hub_id} -g $rg --query id -o tsv)
    wait_until_finished $vpngw_id
    vpncx_json_string=$(jq -n \
            --arg cx_name "hub${hub_id}tobranch${branch_id}" \
            --arg site_id "${site_id}" \
            --arg site_link_id ${site_link_id} \
            --arg psk $password \
            $vpncx_json)
    vpngw_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn${hub_id}"
    vpngw_cx_uri="${vpngw_base_uri}/vpnConnections/branch${hub_id}${branch_id}?api-version=$vwan_api_version"
    # Optional: configure some additional attributes:
    # rt1_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub1/hubRouteTables/hub1NvaRouteTable
    # rt2_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/hub2/hubRouteTables/hub2NvaRouteTable
    # rt3_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/hub1BlueRT
    # rt4_id=/subscriptions/$subscription/resourceGroups/vwan/providers/Microsoft.Network/virtualHubs/$hub_name/hubRouteTables/commonRouteTable
    # vpncx2_json_string=$(echo $vpncx2_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.ids = [{"id": "'$rt1_id'"}, {"id": "'$rt2_id'"}]')
    # Send PUT
    az rest --method put --uri $vpngw_cx_uri --body $vpncx_json_string  # PUT
}

# Configures CSR in branch x to connect to a VPN gateway
function configure_csr {
    hub_id=$1
    branch_id=$2

    branch_asn=6550${branch_id}

    vpngw1_name=hubvpn1
    vpngw1_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/$vpngw1_name?api-version=$vwan_api_version"
    vpngw1=$(az rest --method get --uri $vpngw1_uri)
    vpngw1_gw0_pip=$(echo $vpngw1 | jq -r '.properties.ipConfigurations[0].publicIpAddress')
    vpngw1_gw1_pip=$(echo $vpngw1 | jq -r '.properties.ipConfigurations[1].publicIpAddress')
    vpngw1_gw0_bgp_ip=$(echo $vpngw1 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[0].defaultBgpIpAddresses[0]')
    vpngw1_gw1_bgp_ip=$(echo $vpngw1 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[1].defaultBgpIpAddresses[0]')
    echo "Extracted info for vpngw1: Gateway0 $vpngw1_gw0_pip, $vpngw1_gw0_bgp_ip. Gateway1 $vpngw1_gw1_pip, $vpngw1_gw1_bgp_ip."

    vpngw2_name=hubvpn2
    vpngw2_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/$vpngw2_name?api-version=$vwan_api_version"
    vpngw2=$(az rest --method get --uri $vpngw2_uri)
    vpngw2_gw0_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[0].publicIpAddress')
    vpngw2_gw1_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[1].publicIpAddress')
    vpngw2_gw0_bgp_ip=$(echo $vpngw2 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[0].defaultBgpIpAddresses[0]')
    vpngw2_gw1_bgp_ip=$(echo $vpngw2 | jq -r '.properties.bgpSettings.bgpPeeringAddresses[1].defaultBgpIpAddresses[0]')
    echo "Extracted info for vpngw2: Gateway0 $vpngw2_gw0_pip, $vpngw2_gw0_bgp_ip. Gateway1 $vpngw2_gw1_pip, $vpngw2_gw1_bgp_ip."

    csr_config_url="https://raw.githubusercontent.com/erjosito/azure-wan-lab/master/csr_config_4tunnels_tokenized.txt"
    config_file_csr='branch${branch_id}_csr.cfg'
    config_file_local='/tmp/branch${branch_id}_csr.cfg'
    wget $csr_config_url -O $config_file_local
    sed -i "s|\*\*PSK\*\*|${password}|g" $config_file_local
    sed -i "s|\*\*GW0_Private_IP\*\*|${vpngw1_gw0_bgp_ip}|g" $config_file_local
    sed -i "s|\*\*GW1_Private_IP\*\*|${vpngw1_gw1_bgp_ip}|g" $config_file_local
    sed -i "s|\*\*GW2_Private_IP\*\*|${vpngw2_gw0_bgp_ip}|g" $config_file_local
    sed -i "s|\*\*GW3_Private_IP\*\*|${vpngw2_gw1_bgp_ip}|g" $config_file_local
    sed -i "s|\*\*GW0_Public_IP\*\*|${vpngw1_gw0_pip}|g" $config_file_local
    sed -i "s|\*\*GW1_Public_IP\*\*|${vpngw1_gw1_pip}|g" $config_file_local
    sed -i "s|\*\*GW2_Public_IP\*\*|${vpngw2_gw0_pip}|g" $config_file_local
    sed -i "s|\*\*GW3_Public_IP\*\*|${vpngw2_gw1_pip}|g" $config_file_local
    sed -i "s|\*\*BGP_ID\*\*|${branch_asn}|g" $config_file_local
    # eval "branch_ip=\"\${branch${branch_id}_ip}\""
    branch_ip=$(az network public-ip show -n branch${branch_id}-pip -g $rg -o tsv --query ipAddress)
    echo "Sending config to IP $branch_ip..."
    scp $config_file_local ${branch_ip}:/${config_file_csr}
    ssh -o BatchMode=yes $branch_ip <<EOF
    config t
        file prompt quiet
EOF
    ssh -n -o BatchMode=yes $branch_ip "copy bootflash:${config_file_csr} running-config"
    ssh -n -o BatchMode=yes $branch_ip "wr mem"
    ssh -n -o BatchMode=yes $branch_ip "sh ip int b"
}

############################
#  Create vwan and hubs    #
############################

function create_vwan {
    vwan_name=$1
    location=$2
    vwan_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualWans/${vwan_name}?api-version=$vwan_api_version"
    vwan_json_string=$(jq -n \
        --arg location "$location" \
        --arg sku "Standard" \
        $vwan_json)
    az rest --method put --uri $vwan_uri --body $vwan_json_string
}

function create_hub {
    hub_id=$1
    location=$(get_location $hub_id)
    vwan_name=$(get_vwan_name $hub_id)
    vwan_id=$(az network vwan show -n $vwan_name -g $rg --query id -o tsv)
    vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
    vhub_uri="${vhub_base_uri}?api-version=$vwan_api_version"
    hub_prefix="192.168.${hub_id}.0/24"
    vhub_json_string=$(jq -n \
        --arg location "$location" \
        --arg vwan_id $vwan_id \
        --arg sku "Standard" \
        --arg hub_prefix $hub_prefix \
        $vhub_json)
    az rest --method put --uri $vhub_uri --body $vhub_json_string    # PUT
}

function create_fwpolicy {
    policy_name=$1
    # Firewall policy
    az network firewall policy create -n $policy_name -g $rg
    az network firewall policy rule-collection-group create -n ruleset01 --policy-name $policy_name -g $rg --priority 100
    # Example network collections
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name filter01 --collection-priority 101 --action Allow --rule-name allowSSH --rule-type NetworkRule --description "TCP 22" \
        --destination-addresses "10.0.0.0/8" --source-addresses "10.0.0.0/8" --ip-protocols TCP --destination-ports 22
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name filter02 --collection-priority 102 --action Allow --rule-name allowICMP --rule-type NetworkRule --description "ICMP traffic" \
        --destination-addresses "10.0.0.0/8" --source-addresses "10.0.0.0/8" --ip-protocols ICMP --destination-ports "1-65535"
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name ntp --collection-priority 103 --action Allow --rule-name allowNTP --rule-type NetworkRule --description "ICMP traffic" \
        --destination-addresses "10.0.0.0/8" --source-addresses "0.0.0.0/0" --ip-protocols UDP --destination-ports "123"
    # Example application collection with 2 rules
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name ifconfig --collection-priority 201 --action Allow --rule-name allowIfconfig --rule-type ApplicationRule --description "ifconfig" \
        --target-fqdns "ifconfig.co" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443
    az network firewall policy rule-collection-group collection rule add -g $rg --policy-name $policy_name --rule-collection-group-name ruleset01 --collection-name ifconfig \
        --name ipify --target-fqdns "api.ipify.org" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443 --rule-type ApplicationRule
    # Example application collection with wildcards
    az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
        --name ubuntu --collection-priority 202 --action Allow --rule-name repos --rule-type ApplicationRule --description "ubuntucom" \
        --target-fqdns "*.ubuntu.com" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443
}

function create_fw {
    hub_id=$1
    policy_name=$2
    location=$(get_location $hub_id)
    azfw_id=$(az network firewall show -n azfw${hub_id} -g $rg -o tsv --query id 2>/dev/null)
    if [[ -z $azfw_id ]]
    then
        az network firewall create -n azfw${hub_id} -g $rg --vhub hub${hub_id} --policy $policy_name -l $location --sku AZFW_Hub --public-ip-count 1
        azfw_id=$(az network firewall show -n azfw${hub_id} -g $rg -o tsv --query id)
    else
        echo "Firewall azfw${hub_id} already exists, no need to recreate"
    fi
    az monitor diagnostic-settings create -n mydiag --resource $azfw_id --workspace $logws_id \
        --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
        --logs '[{"category": "AzureFirewallApplicationRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
                {"category": "AzureFirewallNetworkRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]'
}

function delete_fw {
    hub_id=$1
    az network firewall delete -n azfw${hub_id} -g $rg
}

###################
#  Create vnets   #
###################

# Creates spoke vnets and connects it to hub
# create_spokes <hub_id> <number_of_spokes>
# create_spokes 1 5
function create_spokes {
    hub_id=$1
    hub_name=hub${hub_id}
    num_of_spokes=$2
    location=$(get_location $hub_id)
    # Create route-table to send traffic to this PC over Internet
    mypip=$(curl -s4 ifconfig.co)
    echo "Creating route table to send traffic to $mypip over the Internet..."
    az network route-table create -n jumphost-$location -g $rg -l $location >/dev/null
    az network route-table route create -n mypc -g $rg --route-table-name jumphost-$location --address-prefix "${mypip}/32" --next-hop-type Internet >/dev/null
    # Create spokes
    echo "Starting creating $num_of_spokes spokes in $location to attach to hub${hub_id}"
    for (( spoke_id=1 ; spoke_id <= ${num_of_spokes}; spoke_id++ ))
    do
        # Set variables
        # Create jump host
        vm_name=spoke${hub_id}${spoke_id}
        pip_name=${vm_name}-pip
        vnet_name=${vm_name}-$location
        vnet_prefix=10.${hub_id}.${spoke_id}.0/24
        subnet_prefix=10.${hub_id}.${spoke_id}.64/26
        vm_ip=10.${hub_id}.${spoke_id}.75
        echo "Creating VM ${vm_name}-jumphost..."
        vm_id=$(az vm show -n ${vm_name}-jumphost -g $rg --query id -o tsv 2>/dev/null)
        if [[ -z $vm_id ]]
        then
            echo "Creating VM ${vm_name}-jumphost..."
            az vm create -n ${vm_name}-jumphost -g $rg -l $location --image ubuntuLTS --admin-username $username --generate-ssh-keys --size $vm_size \
                    --public-ip-address $pip_name --vnet-name $vnet_name --vnet-address-prefix $vnet_prefix \
                    --subnet jumphost --subnet-address-prefix $subnet_prefix --private-ip-address $vm_ip --no-wait
        else
            echo "VM ${vm_name}-jumphost already exists"
        fi
        # Optionally, add VM without PIP
        # subnet_prefix=10.${hub_id}.${spoke_id}.0/26
        # vm_ip=10.${hub_id}.${spoke_id}.11
        # echo "Creating VM ${vm_name}-test..."
        # az vm create -n ${vm_name}-test -g $rg -l $location --image ubuntuLTS --admin-username $username --generate-ssh-keys --size $vm_size \
        #     --public-ip-address "" --vnet-name $vnet_name --vnet-address-prefix $vnet_prefix \
        #     --subnet vm --subnet-address-prefix $subnet_prefix --private-ip-address $vm_ip --no-wait
    done
    # Do another pass to add the IPs to known_hosts and create vnet-hub connections
    for (( spoke_id=1 ; spoke_id <= ${num_of_spokes}; spoke_id++ ))
    do
        hub_id=$1
        vm_name=spoke${hub_id}${spoke_id}
        pip_name=${vm_name}-pip
        vnet_name=${vm_name}-$location
        # Attach route table to jumphost subnet for SSH traffic
        echo "Attaching route table jumphost-$location to vnet ${vnet_name}..."
        az network vnet subnet update -n jumphost --vnet-name $vnet_name -g $rg --route-table jumphost-$location >/dev/null
        # Get PIP and add it to known_hosts
        echo "Getting IP address for $pip_name..."
        spoke_jump_pip=$(az network public-ip show -n $pip_name -g $rg --query ipAddress -o tsv)
        echo "VM created with public IP $spoke_jump_pip"
        # echo "Adding $spoke_jump_pip to SSH known_hosts..."
        # ssh-keyscan -H $spoke_jump_pip >> ~/.ssh/known_hosts 2>/dev/null
        # ssh -n -o BatchMode=yes $spoke_jump_pip "ip a"
        # Associate vnet to hub
        vnet_id=$(az network vnet show -n $vnet_name -g $rg --query id -o tsv)
        vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
        vhub_uri="${vhub_base_uri}?api-version=$vwan_api_version"
        vhub_vnetcx_uri="${vhub_base_uri}/hubVirtualNetworkConnections/${vm_name}?api-version=$vwan_api_version"
        vnet_cx_json_string=$(jq -n \
                --arg vnet_id "$vnet_id" \
                $vnet_cx_json)
        # Optionally, modify properties for the connection
        # vnet_cx_json_string=$(echo $vnet_cx_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.labels = ["red"]')
        echo "Associating vnet ${vnet_name} to hub hub${hub_id}..."
        # Wait for hub to be Succeeded (do we need to wait for the other connections to be succeeded)
        echo "Waiting for hub to reach the Succeeded state..."
        wait_until_hub_finished $hub_name
        # Create connection
        az rest --method put --uri $vhub_vnetcx_uri --body $vnet_cx_json_string >/dev/null
    done
}

function connect_spoke {
    hub_id=$1
    spoke_id=$2
    location=$(get_location $hub_id)
    vm_name=spoke${hub_id}${spoke_id}
    vnet_name=${vm_name}-$location
    echo "Finding out resource ID for vnet ${vnet_name}..."
    vnet_id=$(az network vnet show -n $vnet_name -g $rg --query id -o tsv)
    vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
    vhub_vnetcx_uri="${vhub_base_uri}/hubVirtualNetworkConnections/${vm_name}?api-version=$vwan_api_version"
    # Create JSON
    vnet_cx_json_string=$(jq -n \
            --arg vnet_id "$vnet_id" \
            $vnet_cx_json)
    # Optionally, modify properties for the connection
    # vnet_cx_json_string=$(echo $vnet_cx_json_string | jq '.properties.routingConfiguration.propagatedRouteTables.labels = ["red"]')
    if [ -n "$BASH_VERSION" ]; then
        arr_opt=a
    elif [ -n "$ZSH_VERSION" ]; then
        arr_opt=A
    fi
    new_assrt_name=$3
    echo "Associating vnet $vnet_name to hub hub${hub_id}..."
    # PUT
    az rest --method put --uri $vhub_vnetcx_uri --body $vnet_cx_json_string >/dev/null
}

function disconnect_spoke {
    hub_id=$1
    spoke_id=$2
    # Variables
    if [[ "$hub_id" == "1" ]]
    then
        location=$location1
    else
        location=$location2
    fi
    vm_name=spoke${hub_id}${spoke_id}
    vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
    vhub_vnetcx_uri="${vhub_base_uri}/hubVirtualNetworkConnections/${vm_name}?api-version=$vwan_api_version"
    # DELETE
    echo "Deleting connection $vm_name..."
    az rest --method delete --uri $vhub_vnetcx_uri
}

function create_nvaspoke {
    hub_id=$1
    create_fw="no"
    hub_name=hub$1
    location=$(get_location $hub_id)
    user_hub_prefix="10.${hub_id}.0.0/24"
    user_hub_subnet="10.${hub_id}.0.0/26"
    user_hub_nva_ip="10.${hub_id}.0.10"
    user_hub_fw_subnet="10.${hub_id}.0.128/26"
    az vm create -n nva${hub_id} -g $rg -l $location --image ubuntuLTS \
        --admin-username $username --generate-ssh-keys \
        --public-ip-address userhub${hub_id}-pip --public-ip-address-allocation static \
        --vnet-name userhub-$location --vnet-address-prefix $user_hub_prefix \
        --subnet nva --subnet-address-prefix $user_hub_subnet \
        --private-ip-address $user_hub_nva_ip --no-wait
    # Az FW in hub 1 (optional)
    if [[ $create_fw == "yes" ]]
    then
        fw_name=userfw${hub_id}
        az network vnet subnet create -n AzureFirewallSubnet --vnet-name userhub-$location -g $rg --address-prefixes $user_hub_fw_subnet
        az network public-ip create -g $rg -n ${fw_name}-pip --sku standard --allocation-method static -l $location
        az network firewall create -n $fw_name -g $rg -l $location
        az network firewall ip-config create -f $fw_name -n userfw-ipconfig -g $rg --public-ip-address userfw1_pip --vnet-name userhub-$location1
        echo "Getting AzFW private IP..."
        userfw_private_ip=$(az network firewall show -n $fw_name -g $rg -o tsv --query 'ipConfigurations[0].privateIpAddress') && echo $userfw_private_ip
        az network route-table route create -n default --route-table-name jumphost-$location -g $rg \
            --next-hop-type VirtualAppliance --address-prefix 0.0.0.0/0 --next-hop-ip-address $userfw_private_ip
    fi
    # IP forwarding
    user_nva_nic_id=$(az vm show -n nva${hub_id} -g $rg --query 'networkProfile.networkInterfaces[0].id' -o tsv)
    az network nic update --ids $user_nva_nic_id --ip-forwarding
    echo "Getting NVA's public IP"
    user_nva_pip=$(az network public-ip show -n userhub${hub_id}-pip -g $rg --query ipAddress -o tsv) && echo $user_nva_pip
    # Connection to hub1
    userhub_vnet_id=$(az network vnet show -n userhub-$location -g $rg --query id -o tsv)
    userhub_cx_json_string=$(jq -n \
            --arg vnet_id "$userhub_vnet_id" \
            $vnet_cx_json)
    vhub_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/virtualHubs/hub${hub_id}"
    vhub_vnetcxhub_uri="${vhub_base_uri}/hubVirtualNetworkConnections/userhub${hub_id}?api-version=$vwan_api_version"
    az rest --method put --uri $vhub_vnetcxhub_uri --body $userhub_cx_json_string  # PUT
    # Route table for future spokes
    az network route-table create -n spokes-$location -g $rg -l $location --disable-bgp-route-propagation
    az network route-table route create -n default -g $rg --route-table-name spokes-$location --address-prefix 0.0.0.0/0 --next-hop-type VirtualAppliance --next-hop-ip-address $user_hub_nva_ip
    echo "Finding out our public IP..."
    mypip=$(curl -s4 ifconfig.co) && echo $mypip
    az network route-table route create -n mypc -g $rg --route-table-name spokes-$location --address-prefix "${mypip}/32" --next-hop-type Internet
    # Configure IP forwarding in OS
    ssh-keyscan -H $user_nva_pip >> ~/.ssh/known_hosts
    ssh -n -o BatchMode=yes $user_nva_pip "sudo sysctl -w net.ipv4.ip_forward=1"
}

function connect_userspoke {
    hub_id=$1
    spoke_id=$2
    location=$(get_location $hub_id)
    az network vnet peering create -n spoke${hub_id}${spoke_id}tohub -g $rg --vnet-name spoke${hub_id}${spoke_id}-$location --remote-vnet userhub-$location --allow-vnet-access --allow-forwarded-traffic
    az network vnet peering create -n hubtospoke${hub_id}${spoke_id} -g $rg --vnet-name userhub-$location --remote-vnet spoke${hub_id}${spoke_id}-$location --allow-vnet-access --allow-forwarded-traffic
    az network vnet subnet update -n vm --vnet-name spoke${hub_id}${spoke_id}-$location -g $rg --route-table spokes-$location 2>/dev/null
    az network vnet subnet update -n jumphost --vnet-name spoke${hub_id}${spoke_id}-$location -g $rg --route-table spokes-$location 2>/dev/null
}

function create_csr {
    hub_id=$1
    branch_id=$2
    location=$(get_location $hub_id)
    hub_name=hub${hub_id}
    branch_name=branch${branch_id}
    branch_vnet_prefix="10.${hub_id}.20${branch_id}.0/24"
    branch_subnet_prefix="10.${hub_id}.20${branch_id}.0/26"
    branch_bgp_ip="10.${hub_id}.20${branch_id}.10"
    # Create CSR
    echo "Creating VM branch${branch_id}-nva in Vnet $branch_vnet_prefix..."
    vm_id=$(az vm show -n branch${branch_id}-nva -g $rg --query id -o tsv 2>/dev/null)
    if [[ -z "$vm_id" ]]
    then
        az vm create -n branch${branch_id}-nva -g $rg -l $location --image ${publisher}:${offer}:${sku}:${version} --size $nva_size \
            --admin-username "$username" --generate-ssh-keys --public-ip-address branch${branch_id}-pip --public-ip-address-allocation static \
            --vnet-name $branch_name --vnet-address-prefix $branch_vnet_prefix --subnet nva --subnet-address-prefix $branch_subnet_prefix \
            --private-ip-address $branch_bgp_ip --no-wait
        sleep 30 # Wait 30 seconds for the creation of the PIP
    else
        echo "VM branch${branch_id}-nva already exists"
    fi
    # Get public IP
    branch_ip=$(az network public-ip show -n branch${branch_id}-pip -g $rg --query ipAddress -o tsv)
    echo "CSR created with IP address $branch_ip. Creating vwan VPN sites now..."
    # Create sites in vwans 1 and 2
    create_site 1 $branch_id $branch_ip $branch_bgp_ip
    sleep 5 # Wait until creating the second site...
    create_site 2 $branch_id $branch_ip $branch_bgp_ip
}

function create_site {
    vwan_id=$1
    branch_id=$2
    branch_public_ip=$3
    branch_private_ip=$4
    site_name="branch${vwan_id}${branch_id}"
    vwan_name=$(get_vwan_name $vwan_id)
    branch_name="branch${branch_id}"
    branch_asn="6550${branch_id}"
    location=$(get_location $vwan_id)
    vwan_id=$(az network vwan show -n $vwan_name -g $rg --query id -o tsv)
    vpnsite_json_string=$(jq -n \
        --arg location "$location" \
        --arg link_name "$branch_name" \
        --arg vwan_id $vwan_id \
        --arg remote_bgp_ip $branch_private_ip \
        --arg remote_asn $branch_asn \
        --arg remote_pip $branch_public_ip \
        --arg site_prefix ${branch_private_ip}/32 \
        --arg security 'false' \
        $vpnsite_json)
    vpnsite_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    echo "Creating site $site_name ($vwan_name to branch$branch_id)..."
    az rest --method put --uri $vpnsite_uri --body $vpnsite_json_string  # PUT
}

# Creates a site and a connection from vwan 1 to vwan 2
# Example create_vwan_site 1 2 10.2.0.0/16
function create_vwan_site {
    vwan1_id=$1
    vwan2_id=$2
    vwan2_prefix=$3
    vpngw2_name=hubvpn${vwan2_id}
    vpngw2_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/$vpngw2_name?api-version=$vwan_api_version"
    vpngw2=$(az rest --method get --uri $vpngw2_uri)
    vpngw2_gw0_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[0].publicIpAddress')
    vpngw2_gw1_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[1].publicIpAddress')
    echo "Extracted info for vpngw in vwan $vwan2_id: gateway0 $vpngw2_gw0_pip, gateway1 $vpngw2_gw1_pip."
    vwan1_name=$(get_vwan_name $vwan1_id)
    location=$(get_location $vwan1_id)
    vwan_id=$(az network vwan show -n $vwan1_name -g $rg --query id -o tsv)

    site_name="vwan${vwan2_id}-gw0"
    vpnsite_json_string=$(jq -n \
        --arg location "$location" \
        --arg link_name "$site_name" \
        --arg vwan_id $vwan_id \
        --arg remote_pip $vpngw2_gw0_pip \
        --arg site_prefix ${vwan2_prefix} \
        --arg security 'false' \
        $vpnsite_nobgp_json)
    vpnsite_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    echo "Creating site ${site_name}..."
    az rest --method put --uri $vpnsite_uri --body $vpnsite_json_string  # PUT

    site_name="vwan${vwan2_id}-gw1"
    vpnsite_json_string=$(jq -n \
        --arg location "$location" \
        --arg link_name "$site_name" \
        --arg vwan_id $vwan_id \
        --arg remote_pip $vpngw2_gw1_pip \
        --arg site_prefix ${vwan2_prefix} \
        --arg security 'false' \
        $vpnsite_nobgp_json)
    vpnsite_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    echo "Creating site ${site_name}..."
    az rest --method put --uri $vpnsite_uri --body $vpnsite_json_string  # PUT

}

# Configures static routes in the CSR for the GW PIPs pointing to its outbound interface
# WORK IN PROGRESS!!!!
function static_csr {
    vpngw2_name=hubvpn${vwan2_id}
    vpngw2_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/$vpngw2_name?api-version=$vwan_api_version"
    vpngw2=$(az rest --method get --uri $vpngw2_uri)
    vpngw2_gw0_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[0].publicIpAddress')
    vpngw2_gw1_pip=$(echo $vpngw2 | jq -r '.properties.ipConfigurations[1].publicIpAddress')
}

function connect_vwan_site {
    vwan1_id=$1
    vwan2_id=$2
    # GW0
    site_name=vwan${vwan2_id}-gw0
    echo "Connecting site $site_name to VPN gateway hubvpn${vwan1_id}..."
    site_id=$(az network vpn-site show -n $site_name -g $rg --query id -o tsv)
    vpnsite_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    site_link_id=$(az rest --method get --uri $vpnsite_uri | jq -r '.properties.vpnSiteLinks[0].id')
    vpngw_id=$(az network vpn-gateway show -n hubvpn${vwan1_id} -g $rg --query id -o tsv)
    wait_until_finished $vpngw_id
    vpncx_json_string=$(jq -n \
            --arg cx_name "${site_name}" \
            --arg site_id "${site_id}" \
            --arg site_link_id ${site_link_id} \
            --arg psk $password \
            $vpncx_nobgp_json)
    vpngw_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn${vwan1_id}"
    vpngw_cx_uri="${vpngw_base_uri}/vpnConnections/${site_name}?api-version=$vwan_api_version"
    az rest --method put --uri $vpngw_cx_uri --body $vpncx_json_string  # PUT
    # GW1
    site_name=vwan${vwan2_id}-gw1
    echo "Connecting site $site_name to VPN gateway hubvpn${vwan1_id}..."
    site_id=$(az network vpn-site show -n $site_name -g $rg --query id -o tsv)
    vpnsite_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnSites/${site_name}?api-version=$vwan_api_version"
    site_link_id=$(az rest --method get --uri $vpnsite_uri | jq -r '.properties.vpnSiteLinks[0].id')
    vpngw_id=$(az network vpn-gateway show -n hubvpn${vwan1_id} -g $rg --query id -o tsv)
    wait_until_finished $vpngw_id
    vpncx_json_string=$(jq -n \
            --arg cx_name "${site_name}" \
            --arg site_id "${site_id}" \
            --arg site_link_id ${site_link_id} \
            --arg psk $password \
            $vpncx_nobgp_json)
    vpngw_base_uri="https://management.azure.com/subscriptions/$subscription_id/resourceGroups/$rg/providers/Microsoft.Network/vpnGateways/hubvpn${vwan1_id}"
    vpngw_cx_uri="${vpngw_base_uri}/vpnConnections/${site_name}?api-version=$vwan_api_version"
    az rest --method put --uri $vpngw_cx_uri --body $vpncx_json_string  # PUT
}

function sh_ip_int_b {
    branch_ip_list=$(az network public-ip list -g $rg -o tsv --query "[?contains(name,'branch')].[ipAddress]")
    while IFS= read -r branch_ip; do
        echo "sh ip int brief on CSR with IP ${branch_ip}..."
        remote $branch_ip "sh ip int b"
    done <<< "$branch_ip_list"
}

function branch_cmd {
    if [[ -z "$1" ]]
    then
        cmd="sh ip int b"
    else
        cmd=$1
    fi
    branch_ip_list=$(az network public-ip list -g $rg -o tsv --query "[?contains(name,'branch')].[ipAddress]")
    while IFS= read -r branch_ip; do
        echo "\"$cmd\" on CSR with IP ${branch_ip}..."
        remote $branch_ip "\"$cmd\""
    done <<< "$branch_ip_list"
}


###################
#      Help       #
###################

function get_help {
    echo 'These functions are defined:'
    echo 'Virtual hubs:'
    echo '  get_vhub [hub_name]: get JSON for all or one hub'
    echo '  get_vhub_state [hub_name]: get state of all or one hub'
    echo '  reset_vhub <hub_name>: resends hub config'
    echo 'Virtual network connections:'
    echo '  create_spokes <1|2|3> <no_of_spokes>: Creates a bunch of vnets in one location'
    echo '  connect spoke <1|2|3> <spoke_id>': connects a spoke to a hub
    echo '  connect userspoke <1|2|3> <spoke_id>': connects a spoke to an NVA vnet
    echo '  disconnect spoke <1|2|3> <spoke_id>': connects a spoke to a hub
    echo '  get_vnetcx_state <hub_name> [cx_name]: JSON for all or one connections in a hub'
    echo '  get_vnetcx <hub_name> [cx_name]: state of all or one connections in a hub'
    echo '  get_cx_labels <hub_name> <cx_name>: get labels of a vnet connection'
    echo '  cx_set_ass_rt <gw_name> <cx_name> rt1: sets associated RT for a connection'
    echo '  cx_set_prop_rt <gw_name> <cx_name> <rt1,rt2>: sets propagation RT IDs for a connection'
    echo '  cx_set_rt <hub_name> <cx_name> <associated_rt> <prop_rt1,prop_rt2>: sets routing config in cx'
    echo '  cx_add_routes <hub_name> <cx_name> <prefix> <next_hop>: adds a static route to a connection'
    echo '  cx_delete_routes <hub_name> <cx_name>: deletes all static routes'
    echo '  cx_set_prop_labels <hub_name> <cx_name> <label1,label2>: sets propagation labels for a connection'
    echo '  cx_delete_labels <hub_name> <cx_name>: deletes all propagating labels'
    echo '  reset_vhub_cx <hub_name> <cx_name>: resends vnet connection config'
    echo 'Route tables:'
    echo '  create_rt <hub_name> <rt_name>: creates a route table'
    echo '  get_rt <hub_name> [rt_name]: JSON for all or one route table'
    echo '  get_rt_state <hub_name> [rt_name]: state for all or one route table'
    echo '  get_rt_labels <hub_name> <rt_name>: get labels for a route table'
    echo '  rt_add_routes <hub_name> <cx_name> <prefix> <next_hop>: adds a static route to a route table'
    echo '  rt_delete_routes <hub_name> <rt_name>: deletes all static routes in a route table'
    echo '  rt_add_label <hub_name> <rt_name> <label>'
    echo '  delete_rt_labels <hub_name> <rt_name>: delete all labels of a route table'
    echo '  delete_rt <hub_name> <rt_name>: deletes a route table'
    echo 'VPN gateways:'
    echo '  create_vpngw <1|2>: creates VPN gateway'
    echo '  delete_vpngw <1|2>: deletes VPN gateway'
    echo '  get_vpngw [gw_name]: JSON for all or one VPN gateway'
    echo '  get_vpngw [gw_name]: JSON for all or one VPN gateway'
    echo '  get_vpngw_state: state of vpn gateways'
    echo 'VPN connections:'
    echo '  connect_branch <1|2|3> <branch_id>: connect branch to hub'
    echo '  configure_csr <hub_id> <branch_id>: configure a certain CSR to connect to a certain branch'
    echo '  get_vpngw_cx <gw_name> [site_name]: get JSON for all or one connections of a VPN gateway'
    echo '  get_vpngw_cx_state <gw_name>: get state for all or one connections of a VPN gateway'
    echo '  get_vpncx_routing <gw_name>: get routing config for all or one connections of a VPN gateway'
    echo '  get_vpncx_labels <gw_name> <cx_name>: get labels for a connections of a VPN gateway'
    echo '  vpncx_set_prop_rt <gw_name> <cx_name> <rt1,rt2>: sets propagation labels for a connection'
    echo '  vpncx_set_prop_labels <gw_name> <cx_name> <label1,label2>: sets propagation labels for a connection'
    echo 'Summary:'
    echo '  labels: prints label configuration for all connections and route tables'
    echo '  routing: prints routing configuration for all connections and route tables'
    echo '  state: prints provisioningState for all connections and route tables'
    echo 'Firewall logs:'
    echo '  get_fw_logs_net: shows network rule logs'
    echo '  get_fw_logs_app: shows app rule logs'
    echo 'Maintenance:'
    echo '  stop_vms: stops all CSRs, jump hosts and test vms'
    echo '  start_vms: starts all CSRs, jump hosts and test vms'
    echo '  get_ips: get public IP addresses of jump hosts and CSRs'
}

###################
# RG, VWAN, vHubs #
###################

# RG
az group create -n $rg -l $location1

# vwans
create_vwan $vwan1_name $location1
create_vwan $vwan2_name $location2

# hub2
create_hub 1
create_hub 2

####################
# S2S VPN Branches #
####################

# CSRs and sites
create_csr 1 1
create_csr 2 2

# vpn gateways
create_vpngw 1
create_vpngw 2

# vpn connections
connect_branch 1 1 # vwan1 <-> branch1
connect_branch 1 2 # vwan1 <-> branch2
connect_branch 2 1 # vwan2 <-> branch1
connect_branch 2 2 # vwan2 <-> branch2

# Verify CSR connectivity
ssh $(az network public-ip show -n branch1-pip -g $rg --query ipAddress -o tsv) "sh ip int b"
ssh $(az network public-ip show -n branch2-pip -g $rg --query ipAddress -o tsv) "sh ip int b"

# configure CSRs (wait until they are fully provisioned)
configure_csr 1 1
configure_csr 2 2

#################
#     Vnets     #
#################

# hub1
create_spokes 1 2
#connect_spoke 1 1
#connect_spoke 1 2
# hub 2
create_spokes 2 2
#connect_spoke 2 1
#connect_spoke 2 2

###########################
# VWAN to VWAN connection #
###########################

create_vwan_site 1 2 10.2.0.0/16
connect_vwan_site 1 2
create_vwan_site 2 1 10.1.0.0/16
connect_vwan_site 2 1

#################
#       FW      #
#################

init_log_vars
create_fwpolicy twovwans
create_fw 1 twovwans
create_fw 2 twovwans

####################################
# Static routes and custom routing #
####################################

# All connections (vnet and branches) should propagate to None
cx_set_rt hub1 spoke11 hub1VnetRT hub1VnetRT vnet
cx_set_rt hub1 spoke12 hub1VnetRT hub1VnetRT vnet
cx_set_rt hub2 spoke21 hub2VnetRT hub2VnetRT vnet
cx_set_rt hub2 spoke22 hub2VnetRT hub2VnetRT vnet
vpncx_set_prop_rt hubvpn1 branch11 defaultRouteTable default
vpncx_set_prop_rt hubvpn1 branch12 defaultRouteTable default
vpncx_set_prop_rt hubvpn1 vwan2-gw0 defaultRouteTable default
vpncx_set_prop_rt hubvpn1 vwan2-gw1 defaultRouteTable default
vpncx_set_prop_rt hubvpn2 branch21 defaultRouteTable default
vpncx_set_prop_rt hubvpn2 branch22 defaultRouteTable default
vpncx_set_prop_rt hubvpn2 vwan1-gw0 defaultRouteTable default
vpncx_set_prop_rt hubvpn2 vwan1-gw1 defaultRouteTable default

# Static routes (only defaults required)
azfw1_id=$(az network firewall show -n azfw1 -g $rg -o tsv --query id)
rt_add_route hub1 defaultRouteTable 0.0.0.0/0 $azfw1_id 
rt_add_route hub1 defaultRouteTable 10.1.1.0/24 $azfw1_id 
rt_add_route hub1 defaultRouteTable 10.1.2.0/24 $azfw1_id 
rt_add_route hub1 defaultRouteTable 10.2.0.0/16 $azfw1_id 
azfw2_id=$(az network firewall show -n azfw2 -g $rg -o tsv --query id)
rt_add_route hub2 defaultRouteTable 0.0.0.0/0 $azfw2_id 
rt_add_route hub2 defaultRouteTable 10.2.1.0/24 $azfw2_id 
rt_add_route hub2 defaultRouteTable 10.2.2.0/24 $azfw2_id 
rt_add_route hub2 defaultRouteTable 10.1.0.0/16 $azfw2_id 


####################################
# Additional CSR config (optional) #
####################################

# redistribute connected
for id (1 2 3)
do
    eval "branch_ip=\"\${branch${id}_ip}\""
    echo "Configuring CSR with IP ${branch_ip}..."
    ssh -o BatchMode=yes $branch_ip <<EOF
    config t
        router bgp 6550$id
            redistribute connected
        end
    clear ip bgp *
    wr mem
EOF
done

#################
# Log Analytics #
#################

# See https://docs.microsoft.com/azure/virtual-wan/logs-metrics

az monitor log-analytics workspace create -n $logws_name -g $rg
logws_name=$(az monitor log-analytics workspace list -g $rg --query '[0].name' -o tsv)  # In case the log analytics workspace already exists
logws_id=$(az resource list -g $rg -n $logws_name --query '[].id' -o tsv)
hub1_vpngw_id=$(az network vpn-gateway show -n hubvpn1 -g $rg --query id -o tsv)
hub2_vpngw_id=$(az network vpn-gateway show -n hubvpn2 -g $rg --query id -o tsv)
az monitor diagnostic-settings create -n mydiag --resource $hub1_vpngw_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "GatewayDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "TunnelDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "RouteDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "IKEDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]' >/dev/null
az monitor diagnostic-settings create -n mydiag --resource $hub2_vpngw_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "GatewayDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "TunnelDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "RouteDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}},
            {"category": "IKEDiagnosticLog", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]' >/dev/null

######################
# Connectivity tests #
######################

get_ips

# Test connectivity to jump host
ssh -n -o BatchMode=yes $spoke11_jump_pip "ip a"
# spoke to Internet (local vhub)
ssh -n -o BatchMode=yes $spoke11_jump_pip "curl -s4 http://ifconfig.co"
ssh -n -o BatchMode=yes $spoke11_jump_pip "curl -s4 http://api.ipify.org"
# Jump host to spoke vm (intra-vnet)
ssh -n -o BatchMode=yes $spoke11_jump_pip "ping $spoke1_vm_ip -c 3"
# spoke1 to spoke2 (local vhub)
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke1_vm_ip "ping $spoke2_vm_ip -c 3"
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke1_vm_ip "nc -vz $spoke3_vm_ip 22"
# spoke1 to spoke3 (remote vhub)
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke11_vm_ip "ping $spoke3_vm_ip -c 3"
ssh -n -o BatchMode=yes -J $spoke11_jump_pip $spoke11_vm_ip "nc -vz $spoke3_vm_ip 22"
# Connectivity to branch1 (local vhub)
ssh -n -o BatchMode=yes $spoke1_jump_pip "ping $branch1_bgp_ip -c 3"
ssh -n -o BatchMode=yes $spoke1_jump_pip "nc -vz $branch1_bgp_ip 22"
# Connectivity to branch2 (remote vhub)
ssh -n -o BatchMode=yes $spoke1_jump_pip "ping $branch2_bgp_ip -c 3"
ssh -n -o BatchMode=yes $spoke1_jump_pip "nc -vz $branch2_bgp_ip 22"
# BGP info in branch1
ssh -n -o BatchMode=yes $branch1_ip "show ip bgp summary"
ssh -n -o BatchMode=yes $branch1_ip "show ip route"
ssh -n -o BatchMode=yes $branch1_ip "show ip route bgp"
# BGP routes in branch2
ssh -n -o BatchMode=yes $branch2_ip "show ip bgp summary"
ssh -n -o BatchMode=yes $branch2_ip "show ip route"
ssh -n -o BatchMode=yes $branch2_ip "show ip route bgp"
# Branch to branch
ssh -n -o BatchMode=yes $branch1_ip "ping $branch2_bgp_ip"

###############
# Secured hub #
###############

# Firewall policy
az network firewall policy create -n $policy_name -g $rg
az network firewall policy rule-collection-group create -n ruleset01 --policy-name $policy_name -g $rg --priority 100
# Example network collections
az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
    --name filter01 --collection-priority 101 --action Allow --rule-name allowSSH --rule-type NetworkRule --description "TCP 22" \
    --destination-addresses "10.0.0.0/8" --source-addresses "10.0.0.0/8" --ip-protocols TCP --destination-ports 22
az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
    --name filter02 --collection-priority 102 --action Allow --rule-name allowICMP --rule-type NetworkRule --description "ICMP traffic" \
    --destination-addresses "10.0.0.0/8" --source-addresses "10.0.0.0/8" --ip-protocols ICMP --destination-ports "1-65535"
az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
    --name ntp --collection-priority 103 --action Allow --rule-name allowNTP --rule-type NetworkRule --description "ICMP traffic" \
    --destination-addresses "10.0.0.0/8" --source-addresses "0.0.0.0/0" --ip-protocols UDP --destination-ports "123"
# Example application collection with 2 rules
az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
    --name ifconfig --collection-priority 201 --action Allow --rule-name allowIfconfig --rule-type ApplicationRule --description "ifconfig" \
    --target-fqdns "ifconfig.co" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443
az network firewall policy rule-collection-group collection rule add -g $rg --policy-name $policy_name --rule-collection-group-name ruleset01 --collection-name ifconfig \
    --name ipify --target-fqdns "api.ipify.org" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443 --rule-type ApplicationRule
# Example application collection with wildcards
az network firewall policy rule-collection-group collection add-filter-collection --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg \
    --name ubuntu --collection-priority 202 --action Allow --rule-name repos --rule-type ApplicationRule --description "ubuntucom" \
    --target-fqdns "*.ubuntu.com" --source-addresses "10.0.0.0/8" --protocols Http=80 Https=443
# Example deleting rules
# az network firewall policy rule-collection-group collection remove --policy-name $policy_name --rule-collection-group-name ruleset01 -g $rg

# Azure Firewalls
az network firewall create -n azfw1 -g $rg --vhub hub1 --policy $policy_name -l $location1 --sku AZFW_Hub --public-ip-count 1
az network firewall create -n azfw2 -g $rg --vhub hub2 --policy $policy_name -l $location2 --sku AZFW_Hub --public-ip-count 1

# Diagnostics
azfw1_id=$(az network firewall show -n azfw1 -g $rg -o tsv --query id)
azfw2_id=$(az network firewall show -n azfw2 -g $rg -o tsv --query id)
# azfw1_id=$(az network firewall show -n userfw1 -g $rg -o tsv --query id)
# azfw2_id=$(az network firewall show -n userfw2 -g $rg -o tsv --query id)
az monitor diagnostic-settings create -n mydiag --resource $azfw1_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "AzureFirewallApplicationRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "AzureFirewallNetworkRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]'
az monitor diagnostic-settings create -n mydiag --resource $azfw2_id --workspace $logws_id \
    --metrics '[{"category": "AllMetrics", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false }, "timeGrain": null}]' \
    --logs '[{"category": "AzureFirewallApplicationRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}, 
            {"category": "AzureFirewallNetworkRule", "enabled": true, "retentionPolicy": {"days": 0, "enabled": false}}]'

#######################
# FW Mgr - RTv2 (old) #
#######################

# Routes in vhub (using the same route table names that the portal generates)
# This is the route for "Traffic for Virtual Networks" and will inject the default in the vnet
# The route injected by the protal has as next hop .132 instead of .68????
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs1_ip
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs2_ip
# This is the route for "Traffic for Branches" and will inject the default in the vnet
# However, the route doesnt appear to be advertised over BGP
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs1_ip
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --destinations "0.0.0.0/0" --next-hop-type IPAddress --next-hops $rs2_ip
# This is the route updates introduced by "Traffic between vnets via Azure Firewall"
# ...excluding the 0/0 for branches
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw1_ip \
    --destinations "0.0.0.0/0" $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub1 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw1_ip \
    --destinations $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 
az network vhub route-table delete -n VirtualNetworkRouteTable -g $rg --vhub-name hub2
az network vhub route-table create -n VirtualNetworkRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw2_ip \
    --destinations "0.0.0.0/0" $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 
az network vhub route-table delete -n BranchRouteTable -g $rg --vhub-name hub2
az network vhub route-table create -n BranchRouteTable -g $rg --vhub-name hub2 --connections All_Vnets \
    --destination-type CIDR --next-hop-type IPAddress --next-hops $azfw2_ip \
    --destinations $spoke1_prefix $spoke2_prefix $branch1_prefix $branch2_prefix 

# If route-tables need to be deleted:
# az network vhub route-table delete -n VnetRouteTable -g $rg --vhub-name hub1
# az network vhub route-table delete -n VnetRouteTable -g $rg --vhub-name hub2

##################
# Red/Blue vnets #
##################

# hub1 RTs
create_rt hub1 hub1RedRT red
create_rt hub1 hub1BlueRT blue
# hub1 cx RT IDs
cx_set_rt hub1 spoke11 hub1RedRT hub1RedRT,defaultRouteTable red,default
cx_set_rt hub1 spoke12 hub1RedRT hub1RedRT,hub1CSRT,defaultRouteTable
cx_set_rt hub1 spoke13 hub1BlueRT hub1BlueRT,hub1CSRT,defaultRouteTable
cx_set_rt hub1 spoke14 hub1CSRT hub1RedRT,hub1BlueRT,hub1CSRT,defaultRouteTable

# hub2 RTs
create_rt hub2 hub2RedRT red
create_rt hub2 hub2BlueRT blue
# hub2 cx RT IDs
cx_set_rt hub2 spoke21 hub2RedRT hub2RedRT,defaultRouteTable
cx_set_rt hub2 spoke22 hub2RedRT hub2RedRT,defaultRouteTable
cx_set_rt hub2 spoke23 hub2BlueRT hub2BlueRT,defaultRouteTable,hub2CSRT
cx_set_rt hub2 spoke24 hub2CSRT hub2BlueRT,hub2RedRT,defaultRouteTable,hub2CSRT

# hub3 RTs
create_rt hub3 hub3RedRT red
create_rt hub3 hub3BlueRT blue
create_rt hub3 hub3CSRT common
# hub3 cx RT IDs
cx_set_rt hub3 spoke31 hub3RedRT hub3RedRT,defaultRouteTable
cx_set_rt hub3 spoke33 hub3BlueRT hub2BlueRT,defaultRouteTable,hub2CSRT
cx_set_rt hub3 spoke34 hub3CSRT hub2BlueRT,hub2RedRT,defaultRouteTable,hub2CSRT
cx_set_rt hub3 userhub3 hub3CSRT hub3CSRT,defaultRouteTable common,default

# Optional: common services RT
create_rt hub1 hub1CSRT common
create_rt hub2 hub2CSRT common
create_rt hub3 hub3CSRT common

# branches
vpncx_set_prop_rt hubvpn3 branch1 defaultRouteTable,hub3RedRT,hub3BlueRT,hub3CSRT default,blue,red,common
vpncx_set_prop_rt hubvpn2 branch2 defaultRouteTable,hub2RedRT,hub2BlueRT,hub2CSRT default,blue,red,common
vpncx_set_prop_rt hubvpn2 branch3 defaultRouteTable,hub1RedRT,hub1BlueRT,hub1CSRT default,blue,red,common

# Add static routes to short-circuit vnets (????)
# spoke1-to-spoke4
spoke1_cx_id=$(az network vhub connection show -n spoke1 --vhub-name hub1 -g $rg --query id -o tsv)
spoke4_cx_id=$(az network vhub connection show -n spoke4 --vhub-name hub2 -g $rg --query id -o tsv)
rt_add_route hub1 hub1RedRT $spoke4_prefix $spoke4_cx_id
rt_add_route hub2 hub1BlueRT $spoke1_prefix $spoke1_cx_id
# Verify:
#   get_vhub_state
#   get_rt_state hub1 hub1RedRT
#   get_rt_state hub2 hub1BlueRT
#   get_rt hub2 hub1RedRT
# Delete
#   rt_delete_routes hub1 hub1RedRT


#################
# FW Mgr (RTv3) #
#################
azfw1_id=$(az network firewall show -n azfw1 -g $rg -o tsv --query id)
azfw2_id=$(az network firewall show -n azfw2 -g $rg -o tsv --query id)
rt_add_route hub1 defaultRouteTable 0.0.0.0/0 $azfw1_id
# Verify:
# get_rt_state hub1
# get_rt hub1 defaultRouteTable
# az network nic show-effective-route-table -n spoke1-vmVMNic -g $rg -o table
# Undo:
# rt_delete_routes hub1 defaultRouteTable
rt_add_route hub2 defaultRouteTable 0.0.0.0/0 $azfw2_id
# Verify:
# get_rt_state hub2
# get_rt hub2 defaultRouteTable
# az network nic show-effective-route-table -n spoke3-vmVMNic -g $rg -o table
# Undo:
# rt_delete_routes hub2 defaultRouteTable


###########
# zScaler #
###########

# Remove role assignment for zscaler SP
keyvault=erjositoKeyvault
appid=$(az keyvault secret show --vault-name $keyvault -n zscaler-app-id --query value -o tsv)
oid=$(az ad sp show --id $appid --query objectId -o tsv)
subid=$(az account show --query id -o tsv)
assignmentid=$(az role assignment list --scope "/subscriptions/${subid}" --assignee $oid --query '[0].id' -o tsv)
if [[ -z $assignmentid ]]
then
    echo "No assignment found for app ID $appid"
else
    az role assignment delete --ids $assignmentid -y
fi
# Add role assignment
appid=$(az keyvault secret show --vault-name erjositoKeyvault -n zscaler-app-id --query value -o tsv)
oid=$(az ad sp show --id $appid --query objectId -o tsv)
subid=$(az account show --query id -o tsv)
az role assignment create --scope "/subscriptions/${subid}" --assignee $oid --role Contributor

#################################
# Troubleshooting / Diagnostics #
#################################

az network public-ip list -g $rg -o table
az network nic list -g $rg -o table
az network nic show-effective-route-table -n spoke1-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke2-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke3-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke4-jumphostVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke1-vmVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke2-vmVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke3-vmVMNic -g $rg -o table
az network nic show-effective-route-table -n spoke4-vmVMNic -g $rg -o table
az network nic show-effective-route-table --ids $user_nva1_nic_id -o table
az network nic show-effective-route-table --ids $user_nva2_nic_id -o table
az network vhub connection list --vhub-name hub1 -g $rg -o table
az network vhub route-table list --vhub-name hub1 -g $rg -o table
az network vhub route list --vhub-name hub1 -g $rg -o table
az network vhub connection list --vhub-name hub2 -g $rg -o table
az network vhub route-table list --vhub-name hub2 -g $rg -o table
az network vhub route list --vhub-name hub2 -g $rg -o table
az network vpn-site list -g $rg -o table
az network vpn-gateway list -g $rg -o table
az network vpn-gateway connection list --gateway-name hubvpn1 -g $rg -o table
az network vpn-gateway connection list --gateway-name hubvpn2 -g $rg -o table
az network firewall policy list -g $rg -o table
az network firewall policy rule-collection-group list --policy $policy_name -g $rg -o table
az network firewall policy rule-collection-group collection list --policy $policy_name -g $rg --rule-collection-group-name ruleset01 -o table 
az network firewall policy rule-collection-group collection list --policy $policy_name -g $rg --rule-collection-group-name ruleset01   # There are no 'collection show' or 'collection rule list' commands
ssh -n -o BatchMode=yes $username@$branch1_ip "sh ip bgp"
ssh -n -o BatchMode=yes $username@$branch1_ip "sh ip interface brief"
ssh -n -o BatchMode=yes $username@$branch1_ip "sh ip route"

# Get hubs
az rest --method get --uri $vhubs_uri | jq '.value'
az rest --method get --uri $vhubs_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
# Get hub details
az rest --method get --uri $vhub1_uri
# Get hub ipconfig (not working)
az rest --method get --uri $vhub1_ipconfigs_uri
# Get hub vnet connections
az rest --method get --uri $vhub1_vnetcx_uri
az rest --method get --uri $vhub1_vnetcx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vhub1_vnetcx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
az rest --method get --uri $vhub2_vnetcx_uri
az rest --method get --uri $vhub2_vnetcx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vhub2_vnetcx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
# Get RTv2 (aka routeTable)
az rest --method get --uri $vhub1_rt_uri
# Get hub RTs (aka hubRouteTable)
az rest --method get --uri $vhub1_hubrt_uri
az rest --method get --uri $vhub1_hubrt_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vhub2_hubrt_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
# Get hub default hubRT
az rest --method get --uri $vhub1_default_hubrt_uri
az rest --method get --uri $vhub2_default_hubrt_uri
# Get hub BGP connections (NOT WORKING!!!)
az rest --method get --uri $vhub1_bgp_uri
# Get hub effective routes (NOT WORKING!!!)
az rest --method get --uri $vhub1_effrt_uri
# Get VPN GWs
az rest --method get --uri $vpngws_uri
az rest --method get --uri $vpngws_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
 # Get VPN GW details
az rest --method get --uri $vpngw1_uri
az rest --method get --uri $vpngw2_uri
# Get VPN GW connections
az rest --method get --uri $vpngw1_cx_uri
az rest --method get --uri $vpngw1_cx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vpngw1_cx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
az rest --method get --uri $vpngw2_cx_uri
az rest --method get --uri $vpngw2_cx_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'
az rest --method get --uri $vpngw2_cx_uri | jq -r '.value | map({name, associatedRT: .properties.routingConfiguration.associatedRouteTable.id, propagateRTs: .properties.routingConfiguration.propagatedRouteTables.ids[].id})'
# Get VPN Sites
az rest --method get --uri $vpnsites_uri
az rest --method get --uri $vpnsites_uri | jq -r '.value | map({name, provisioningState: .properties.provisioningState})'

##########################
# Delete AzFW and vpnGWs #
##########################

stop_vms
delete_vpngw 1
delete_vpngw 2
delete_vpngw 3
delete_fw 1
delete_fw 2
delete_fw 3

#########################
# Log Analytics queries #
#########################

logws_customerid=$(az monitor log-analytics workspace show -n $logws_name -g $rg --query customerId -o tsv)
# Log summary
query='AzureDiagnostics 
| where TimeGenerated >= ago(15m) 
| summarize count() by ResourceType'
# AZFW log summary
query='AzureDiagnostics 
| where ResourceType == "AZUREFIREWALLS" 
//| summarize count() by Category
| summarize count() by bin(TimeGenerated, 1h), Category
| where TimeGenerated >= ago(6h)'
# AzFW app rule deny logs
query='AzureDiagnostics 
| where ResourceType == "AZUREFIREWALLS" 
| where Category == "AzureFirewallApplicationRule" 
| where TimeGenerated >= ago(5m) 
| project Protocol=split(msg_s, " ")[0], From=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",3,4)], To=split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",5,6)], Action=trim_end(".", tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",7,8)])), Rule_Collection=iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="traffic.", "AzureInternalTraffic", iif(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)]=="matched.","NoRuleMatched",trim_end(".",tostring(split(msg_s, " ")[iif(split(msg_s, " ")[0]=="HTTPS",10,11)])))), Rule=iif(split(msg_s, " ")[11]=="Proceeding" or split(msg_s, " ")[12]=="Proceeding","DefaultAction",split(msg_s, " ")[12]), msg_s 
| where Rule_Collection != "AzureInternalTraffic" 
//| where Action == "Deny" 
| where Action == "Allow" 
| take 5'
# AzFW net rule logs
query='AzureDiagnostics
| where Category == "AzureFirewallNetworkRule"
| where TimeGenerated >= ago(5m) 
| parse msg_s with Protocol " request from " SourceIP ":" SourcePortInt:int " to " TargetIP ":" TargetPortInt:int *
| parse msg_s with * ". Action: " Action1a
| parse msg_s with * " was " Action1b " to " NatDestination
| parse msg_s with Protocol2 " request from " SourceIP2 " to " TargetIP2 ". Action: " Action2
| extend SourcePort = tostring(SourcePortInt),TargetPort = tostring(TargetPortInt)
| extend Action = case(Action1a == "", case(Action1b == "",Action2,Action1b), Action1a),Protocol = case(Protocol == "", Protocol2, Protocol),SourceIP = case(SourceIP == "", SourceIP2, SourceIP),TargetIP = case(TargetIP == "", TargetIP2, TargetIP),SourcePort = case(SourcePort == "", "N/A", SourcePort),TargetPort = case(TargetPort == "", "N/A", TargetPort),NatDestination = case(NatDestination == "", "N/A", NatDestination)
//| where Action == "Deny" 
//| project TimeGenerated, msg_s, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // with msg_s
| project TimeGenerated, Protocol, SourceIP,SourcePort,TargetIP,TargetPort,Action, NatDestination  // without msg_s
| where TargetPort == "22"
| take 20 '
# VPNGW log summary
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where TimeGenerated >= ago(5m) 
| summarize count() by Category'
# VPNGW IKE diagnostics
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "IKEDiagnosticLog" 
| where TimeGenerated >= ago(5m) 
| project Message
| take 10'
# VPNGW Route diagnostics (BGP connected/disconnected events)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "RouteDiagnosticLog" 
| where TimeGenerated >= ago(2h) 
| project TimeGenerated, Resource, peerAddress_s, OperationName, Message
| take 20'
# VPNGW Route diagnostics summary (the presence of logs indicate BGP adjacency instability)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "RouteDiagnosticLog" 
| where TimeGenerated >= ago(6h) 
| summarize count() by OperationName'
# VPNGW Tunnel diagnostics summary (the presence of logs indicate tunnel instability)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "TunnelDiagnosticLog" 
| where TimeGenerated >= ago(2h) 
| summarize count() by OperationName'
# VPNGW Tunnel diagnostics (the presence of logs indicate tunnel instability)
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where Category == "TunnelDiagnosticLog" 
| where TimeGenerated >= ago(15m) 
| project TimeGenerated, Resource, remoteIP_s, stateChangeReason_s, status_s
| take 20'
# VPNGW Gateway log summary
query='AzureDiagnostics 
| where ResourceType == "VPNGATEWAYS" 
| where TimeGenerated >= ago(10m) 
| summarize count() by Category'
# Search somehting
query='search "azfw"'
# Send query
az monitor log-analytics query -w $logws_customerid --analytics-query $query -o tsv
